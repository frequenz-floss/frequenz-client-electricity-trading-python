{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Electricity Trading API Client","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Electricity Trading API client for Python The Frequenz Electricity Trading API client for Python is an easy-to-use Python interface built to interact with the Frequenz Electricity Trading API. It allows you to create orders, get market data, and manage your orders.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Create and manage gridpool orders: Place new orders, update existing ones, and cancel orders when necessary.</li> <li>Stream live data: Get real-time updates on market data, including order books, trades, and market prices.</li> <li>Retrieve historical data: Access historical data on market trades.</li> </ul>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#installation","title":"Installation","text":"<p>You can install the Frequenz Electricity Trading API client via pip. Replace <code>VERSION</code> with the specific version you wish to install.</p> <pre><code># Choose the version you want to install\nVERSION=0.2.2\npip install frequenz-client-electricity-trading==$VERSION\n</code></pre>"},{"location":"#initialization","title":"Initialization","text":"<p>First, initialize the client with the appropriate server URL and API key. <pre><code>from frequenz.client.electricity_trading import Client\n\n# Change server address if needed\nSERVICE_URL = \"grpc://electricity-trading.api.frequenz.com:443?ssl=true\"\nAPI_KEY = open('/path/to/api_key.txt').read().strip()\nclient = Client(\n    server_url=SERVICE_URL,\n    auth_key=API_KEY\n)\n</code></pre></p>"},{"location":"#create-an-order","title":"Create an Order","text":"<p>Here's an example of how one can create a limit order to buy energy. <pre><code>from frequenz.client.electricity_trading import (\n    Currency,\n    DeliveryArea,\n    DeliveryPeriod,\n    Energy,\n    EnergyMarketCodeType,\n    MarketSide,\n    OrderType,\n    Price,\n)\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\n\n# Define order parameters\ngridpool_id = 1\ndelivery_area = DeliveryArea(\n    code=\"10YDE-EON------1\", # TenneT\n    code_type=EnergyMarketCodeType.EUROPE_EIC\n)\ndelivery_period = DeliveryPeriod(\n    start=datetime.fromisoformat(\"2024-05-01T00:00:00\"),\n    duration=datetime.timedelta(minutes=15)\n)\nprice = Price(amount=Decimal(\"50.0\"), currency=Currency.EUR)\nquantity = Energy(mwh=Decimal(\"0.1\"))\norder = await client.create_gridpool_order(\n    gridpool_id=gridpool_id,\n    delivery_area=delivery_area,\n    delivery_period=delivery_period,\n    order_type=OrderType.LIMIT,\n    side=MarketSide.BUY,\n    price=quantity,\n    quantity=quantity,\n)\n</code></pre></p>"},{"location":"#list-orders-for-a-gridpool","title":"List Orders for a Gridpool","text":"<p>Orders for a given gridpool can be listed using various filters.</p> <pre><code>from frequenz.client.electricity_trading import MarketSide\n\n# List all orders for a given gridpool\norders = await self._client.list_gridpool_orders(\n    gridpool_id=gridpool_id,\n)\n\n# List only the buy orders for a given gridpool\nbuy_orders = await self._client.list_gridpool_orders(\n    gridpool_id=gridpool_id,\n    side=MarketSide.BUY,\n)\n</code></pre>"},{"location":"#streaming-public-trades","title":"Streaming Public Trades","text":"<p>To get real-time updates on market trades, one can use the following code snippet.</p> <pre><code>async for public_trade in client.stream_public_trades():\n    print(f\"Received public trade: {public_trade}\")\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Electricity Trading API Client","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>client<ul> <li>electricity_trading</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/client/electricity_trading/","title":"electricity_trading","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading","title":"frequenz.client.electricity_trading","text":"<p>Electricity Trading API client for Python.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client","title":"frequenz.client.electricity_trading.Client","text":"<p>               Bases: <code>BaseApiClient[ElectricityTradingServiceStub, Channel]</code></p> <p>Electricity trading client.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>class Client(BaseApiClient[ElectricityTradingServiceStub, grpc.aio.Channel]):\n    \"\"\"Electricity trading client.\"\"\"\n\n    def __init__(\n        self, server_url: str, connect: bool = True, auth_key: str | None = None\n    ) -&gt; None:\n        \"\"\"Initialize the client.\n\n        Args:\n            server_url: The URL of the Electricity Trading service.\n            connect: Whether to connect to the server immediately.\n            auth_key: The API key for the authorization.\n        \"\"\"\n        super().__init__(\n            server_url, ElectricityTradingServiceStub, grpc.aio.Channel, connect=connect\n        )\n\n        self._gridpool_orders_streams: dict[\n            tuple[int, GridpoolOrderFilter],\n            GrpcStreamBroadcaster[\n                electricity_trading_pb2.ReceiveGridpoolOrdersStreamResponse, OrderDetail\n            ],\n        ] = {}\n\n        self._gridpool_trades_streams: dict[\n            tuple[int, GridpoolTradeFilter],\n            GrpcStreamBroadcaster[\n                electricity_trading_pb2.ReceiveGridpoolTradesStreamResponse, Trade\n            ],\n        ] = {}\n\n        self._public_trades_streams: dict[\n            PublicTradeFilter,\n            GrpcStreamBroadcaster[\n                electricity_trading_pb2.ReceivePublicTradesStreamResponse, PublicTrade\n            ],\n        ] = {}\n\n        self._metadata = ((\"key\", auth_key),) if auth_key else ()\n\n    async def stream_gridpool_orders(  # pylint: disable=too-many-arguments\n        self,\n        gridpool_id: int,\n        order_states: list[OrderState] | None = None,\n        market_side: MarketSide | None = None,\n        delivery_area: DeliveryArea | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        tag: str | None = None,\n    ) -&gt; Receiver[OrderDetail]:\n        \"\"\"\n        Stream gridpool orders.\n\n        Args:\n            gridpool_id: ID of the gridpool to stream orders for.\n            order_states: List of order states to filter for.\n            market_side: Market side to filter for.\n            delivery_area: Delivery area to filter for.\n            delivery_period: Delivery period to filter for.\n            tag: Tag to filter for.\n\n        Returns:\n            Async generator of orders.\n\n        Raises:\n            grpc.RpcError: If an error occurs while streaming the orders.\n        \"\"\"\n        gridpool_order_filter = GridpoolOrderFilter(\n            order_states=order_states,\n            side=market_side,\n            delivery_area=delivery_area,\n            delivery_period=delivery_period,\n            tag=tag,\n        )\n\n        stream_key = (gridpool_id, gridpool_order_filter)\n\n        if stream_key not in self._gridpool_orders_streams:\n            try:\n                self._gridpool_orders_streams[stream_key] = GrpcStreamBroadcaster(\n                    f\"electricity-trading-{stream_key}\",\n                    lambda: self.stub.ReceiveGridpoolOrdersStream(  # type: ignore\n                        electricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest(\n                            gridpool_id=gridpool_id,\n                            filter=gridpool_order_filter.to_pb(),\n                        ),\n                        metadata=self._metadata,\n                    ),\n                    lambda response: OrderDetail.from_pb(response.order_detail),\n                )\n            except grpc.RpcError as e:\n                _logger.exception(\n                    \"Error occurred while streaming gridpool orders: %s\", e\n                )\n                raise e\n        return self._gridpool_orders_streams[stream_key].new_receiver()\n\n    async def stream_gridpool_trades(  # pylint: disable=too-many-arguments\n        self,\n        gridpool_id: int,\n        trade_states: list[TradeState] | None = None,\n        trade_ids: list[int] | None = None,\n        market_side: MarketSide | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        delivery_area: DeliveryArea | None = None,\n    ) -&gt; Receiver[Trade]:\n        \"\"\"\n        Stream gridpool trades.\n\n        Args:\n            gridpool_id: The ID of the gridpool to stream trades for.\n            trade_states: List of trade states to filter for.\n            trade_ids: List of trade IDs to filter for.\n            market_side: The market side to filter for.\n            delivery_period: The delivery period to filter for.\n            delivery_area: The delivery area to filter for.\n\n        Returns:\n            The gridpool trades streamer.\n\n        Raises:\n            grpc.RpcError: If an error occurs while streaming gridpool trades.\n        \"\"\"\n        gridpool_trade_filter = GridpoolTradeFilter(\n            trade_states=trade_states,\n            trade_ids=trade_ids,\n            side=market_side,\n            delivery_period=delivery_period,\n            delivery_area=delivery_area,\n        )\n\n        stream_key = (gridpool_id, gridpool_trade_filter)\n\n        if stream_key not in self._gridpool_trades_streams:\n            try:\n                self._gridpool_trades_streams[stream_key] = GrpcStreamBroadcaster(\n                    f\"electricity-trading-{stream_key}\",\n                    lambda: self.stub.ReceiveGridpoolTradesStream(  # type: ignore\n                        electricity_trading_pb2.ReceiveGridpoolTradesStreamRequest(\n                            gridpool_id=gridpool_id,\n                            filter=gridpool_trade_filter.to_pb(),\n                        ),\n                        metadata=self._metadata,\n                    ),\n                    lambda response: Trade.from_pb(response.trade),\n                )\n            except grpc.RpcError as e:\n                _logger.exception(\n                    \"Error occurred while streaming gridpool trades: %s\", e\n                )\n                raise e\n        return self._gridpool_trades_streams[stream_key].new_receiver()\n\n    async def stream_public_trades(\n        self,\n        states: list[TradeState] | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        buy_delivery_area: DeliveryArea | None = None,\n        sell_delivery_area: DeliveryArea | None = None,\n    ) -&gt; Receiver[PublicTrade]:\n        \"\"\"\n        Stream public trades.\n\n        Args:\n            states: List of order states to filter for.\n            delivery_period: Delivery period to filter for.\n            buy_delivery_area: Buy delivery area to filter for.\n            sell_delivery_area: Sell delivery area to filter for.\n\n        Returns:\n            Async generator of orders.\n\n        Raises:\n            grpc.RpcError: If an error occurs while streaming public trades.\n        \"\"\"\n        public_trade_filter = PublicTradeFilter(\n            states=states,\n            delivery_period=delivery_period,\n            buy_delivery_area=buy_delivery_area,\n            sell_delivery_area=sell_delivery_area,\n        )\n\n        if public_trade_filter not in self._public_trades_streams:\n            try:\n                self._public_trades_streams[public_trade_filter] = (\n                    GrpcStreamBroadcaster(\n                        f\"electricity-trading-{public_trade_filter}\",\n                        lambda: self.stub.ReceivePublicTradesStream(  # type: ignore\n                            electricity_trading_pb2.ReceivePublicTradesStreamRequest(\n                                filter=public_trade_filter.to_pb(),\n                            ),\n                            metadata=self._metadata,\n                        ),\n                        lambda response: PublicTrade.from_pb(response.public_trade),\n                    )\n                )\n            except grpc.RpcError as e:\n                _logger.exception(\"Error occurred while streaming public trades: %s\", e)\n                raise e\n        return self._public_trades_streams[public_trade_filter].new_receiver()\n\n    async def create_gridpool_order(  # pylint: disable=too-many-arguments, too-many-locals\n        self,\n        gridpool_id: int,\n        delivery_area: DeliveryArea,\n        delivery_period: DeliveryPeriod,\n        order_type: OrderType,\n        side: MarketSide,\n        price: Price,\n        quantity: Energy,\n        stop_price: Price | None = None,\n        peak_price_delta: Price | None = None,\n        display_quantity: Energy | None = None,\n        execution_option: OrderExecutionOption | None = None,\n        valid_until: datetime | None = None,\n        payload: dict[str, struct_pb2.Value] | None = None,\n        tag: str | None = None,\n    ) -&gt; OrderDetail:\n        \"\"\"\n        Create a gridpool order.\n\n        Args:\n            gridpool_id: ID of the gridpool to create the order for.\n            delivery_area: Delivery area of the order.\n            delivery_period: Delivery period of the order.\n            order_type: Type of the order.\n            side: Side of the order.\n            price: Price of the order.\n            quantity: Quantity of the order.\n            stop_price: Stop price of the order.\n            peak_price_delta: Peak price delta of the order.\n            display_quantity: Display quantity of the order.\n            execution_option: Execution option of the order.\n            valid_until: Valid until of the order.\n            payload: Payload of the order.\n            tag: Tag of the order.\n\n        Returns:\n            The created order.\n\n        Raises:\n            grpc.RpcError: An error occurred while creating the order.\n        \"\"\"\n        validate_decimal_places(price.amount, PRECISION_DECIMAL_PRICE, \"price\")\n        validate_decimal_places(quantity.mwh, PRECISION_DECIMAL_QUANTITY, \"quantity\")\n        if stop_price is not None:\n            validate_decimal_places(\n                stop_price.amount, PRECISION_DECIMAL_PRICE, \"stop price\"\n            )\n        if peak_price_delta is not None:\n            validate_decimal_places(\n                peak_price_delta.amount, PRECISION_DECIMAL_PRICE, \"peak price delta\"\n            )\n        if display_quantity is not None:\n            validate_decimal_places(\n                display_quantity.mwh, PRECISION_DECIMAL_QUANTITY, \"display quantity\"\n            )\n\n        order = Order(\n            delivery_area=delivery_area,\n            delivery_period=delivery_period,\n            type=order_type,\n            side=side,\n            price=price,\n            quantity=quantity,\n            stop_price=stop_price,\n            peak_price_delta=peak_price_delta,\n            display_quantity=display_quantity,\n            execution_option=execution_option,\n            valid_until=valid_until,\n            payload=payload,\n            tag=tag,\n        )\n\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.CreateGridpoolOrderResponse],\n                self.stub.CreateGridpoolOrder(\n                    electricity_trading_pb2.CreateGridpoolOrderRequest(\n                        gridpool_id=gridpool_id,\n                        order=order.to_pb(),\n                    ),\n                    metadata=self._metadata,\n                ),\n            )\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while creating gridpool order: %s\", e)\n            raise e\n\n        return OrderDetail.from_pb(response.order_detail)\n\n    async def update_gridpool_order(  # pylint: disable=too-many-arguments, too-many-locals\n        self,\n        gridpool_id: int,\n        order_id: int,\n        price: Price | None | _Sentinel = NO_VALUE,\n        quantity: Energy | None | _Sentinel = NO_VALUE,\n        stop_price: Price | None | _Sentinel = NO_VALUE,\n        peak_price_delta: Price | None | _Sentinel = NO_VALUE,\n        display_quantity: Energy | None | _Sentinel = NO_VALUE,\n        execution_option: OrderExecutionOption | None | _Sentinel = NO_VALUE,\n        valid_until: datetime | None | _Sentinel = NO_VALUE,\n        payload: dict[str, struct_pb2.Value] | None | _Sentinel = NO_VALUE,\n        tag: str | None | _Sentinel = NO_VALUE,\n    ) -&gt; OrderDetail:\n        \"\"\"\n        Update an existing order for a given Gridpool.\n\n        Args:\n            gridpool_id: ID of the Gridpool the order belongs to.\n            order_id: Order ID.\n            price: The updated limit price at which the contract is to be traded.\n                This is the maximum price for a BUY order or the minimum price for a SELL order.\n            quantity: The updated quantity of the contract being traded, specified in MWh.\n            stop_price: Applicable for STOP_LIMIT orders. This is the updated stop price that\n                triggers the limit order.\n            peak_price_delta: Applicable for ICEBERG orders. This is the updated price difference\n                between the peak price and the limit price.\n            display_quantity: Applicable for ICEBERG orders. This is the updated quantity of the\n                order to be displayed in the order book.\n            execution_option: Updated execution options such as All or None, Fill or Kill, etc.\n            valid_until: This is an updated timestamp defining the time after which the order\n                should be cancelled if not filled. The timestamp is in UTC.\n            payload: Updated user-defined payload individual to a specific order. This can be any\n                data that the user wants to associate with the order.\n            tag: Updated user-defined tag to group related orders.\n\n        Returns:\n            The updated order.\n\n        Raises:\n            ValueError: If no fields to update are provided.\n        \"\"\"\n        if not isinstance(price, _Sentinel) and price is not None:\n            validate_decimal_places(price.amount, PRECISION_DECIMAL_PRICE, \"price\")\n        if not isinstance(quantity, _Sentinel) and quantity is not None:\n            validate_decimal_places(\n                quantity.mwh, PRECISION_DECIMAL_QUANTITY, \"quantity\"\n            )\n        if not isinstance(stop_price, _Sentinel) and stop_price is not None:\n            validate_decimal_places(\n                stop_price.amount, PRECISION_DECIMAL_PRICE, \"stop price\"\n            )\n        if not isinstance(peak_price_delta, _Sentinel) and peak_price_delta is not None:\n            validate_decimal_places(\n                peak_price_delta.amount, PRECISION_DECIMAL_PRICE, \"peak price delta\"\n            )\n        if not isinstance(display_quantity, _Sentinel) and display_quantity is not None:\n            validate_decimal_places(\n                display_quantity.mwh, PRECISION_DECIMAL_QUANTITY, \"display quantity\"\n            )\n\n        params = {\n            \"price\": price,\n            \"quantity\": quantity,\n            \"stop_price\": stop_price,\n            \"peak_price_delta\": peak_price_delta,\n            \"display_quantity\": display_quantity,\n            \"execution_option\": execution_option,\n            \"valid_until\": valid_until,\n            \"payload\": payload,\n            \"tag\": tag,\n        }\n\n        if all(value is NO_VALUE for value in params.values()):\n            raise ValueError(\"At least one field to update must be provided.\")\n\n        paths = [param for param, value in params.items() if value is not NO_VALUE]\n\n        # Field mask specifying which fields should be updated\n        # This is used so that we can update parameters with None values\n        update_mask = field_mask_pb2.FieldMask(paths=paths)\n\n        update_order_fields = UpdateOrder(\n            price=None if price is NO_VALUE else price,  # type: ignore\n            quantity=None if quantity is NO_VALUE else quantity,  # type: ignore\n            stop_price=None if stop_price is NO_VALUE else stop_price,  # type: ignore\n            peak_price_delta=(\n                None if peak_price_delta is NO_VALUE else peak_price_delta  # type: ignore\n            ),\n            display_quantity=(\n                None if display_quantity is NO_VALUE else display_quantity  # type: ignore\n            ),\n            execution_option=(\n                None if execution_option is NO_VALUE else execution_option  # type: ignore\n            ),\n            valid_until=(\n                None if valid_until is NO_VALUE else valid_until  # type: ignore\n            ),\n            payload=None if payload is NO_VALUE else payload,  # type: ignore\n            tag=None if tag is NO_VALUE else tag,  # type: ignore\n        )\n\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.UpdateGridpoolOrderResponse],\n                self.stub.UpdateGridpoolOrder(\n                    electricity_trading_pb2.UpdateGridpoolOrderRequest(\n                        gridpool_id=gridpool_id,\n                        order_id=order_id,\n                        update_order_fields=update_order_fields.to_pb(),\n                        update_mask=update_mask,\n                    ),\n                    metadata=self._metadata,\n                ),\n            )\n            return OrderDetail.from_pb(response.order_detail)\n\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while updating gridpool order: %s\", e)\n            raise e\n\n    async def cancel_gridpool_order(\n        self, gridpool_id: int, order_id: int\n    ) -&gt; OrderDetail:\n        \"\"\"\n        Cancel a single order for a given Gridpool.\n\n        Args:\n            gridpool_id: The Gridpool to cancel the order for.\n            order_id: The order to cancel.\n\n        Returns:\n            The cancelled order.\n\n        Raises:\n            grpc.RpcError: If an error occurs while cancelling the gridpool order.\n        \"\"\"\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.CancelGridpoolOrderResponse],\n                self.stub.CancelGridpoolOrder(\n                    electricity_trading_pb2.CancelGridpoolOrderRequest(\n                        gridpool_id=gridpool_id, order_id=order_id\n                    ),\n                    metadata=self._metadata,\n                ),\n            )\n            return OrderDetail.from_pb(response.order_detail)\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while cancelling gridpool order: %s\", e)\n            raise e\n\n    async def cancel_all_gridpool_orders(self, gridpool_id: int) -&gt; int:\n        \"\"\"\n        Cancel all orders for a specific Gridpool.\n\n        Args:\n            gridpool_id: The Gridpool to cancel the orders for.\n\n        Returns:\n            The ID of the Gridpool for which the orders were cancelled.\n\n        Raises:\n            grpc.RpcError: If an error occurs while cancelling all gridpool orders.\n        \"\"\"\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.CancelAllGridpoolOrdersResponse],\n                self.stub.CancelAllGridpoolOrders(\n                    electricity_trading_pb2.CancelAllGridpoolOrdersRequest(\n                        gridpool_id=gridpool_id\n                    ),\n                    metadata=self._metadata,\n                ),\n            )\n\n            return response.gridpool_id\n        except grpc.RpcError as e:\n            _logger.exception(\n                \"Error occurred while cancelling all gridpool orders: %s\", e\n            )\n            raise e\n\n    async def get_gridpool_order(self, gridpool_id: int, order_id: int) -&gt; OrderDetail:\n        \"\"\"\n        Get a single order from a given gridpool.\n\n        Args:\n            gridpool_id: The Gridpool to retrieve the order for.\n            order_id: The order to retrieve.\n\n        Returns:\n            The order.\n\n        Raises:\n            grpc.RpcError: If an error occurs while getting the order.\n        \"\"\"\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.GetGridpoolOrderResponse],\n                self.stub.GetGridpoolOrder(\n                    electricity_trading_pb2.GetGridpoolOrderRequest(\n                        gridpool_id=gridpool_id, order_id=order_id\n                    ),\n                    metadata=self._metadata,\n                ),\n            )\n\n            return OrderDetail.from_pb(response.order_detail)\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while getting gridpool order: %s\", e)\n            raise e\n\n    async def list_gridpool_orders(  # pylint: disable=too-many-arguments\n        self,\n        gridpool_id: int,\n        order_states: list[OrderState] | None = None,\n        side: MarketSide | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        delivery_area: DeliveryArea | None = None,\n        tag: str | None = None,\n        max_nr_orders: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; list[OrderDetail]:\n        \"\"\"\n        List orders for a specific Gridpool with optional filters.\n\n        Args:\n            gridpool_id: The Gridpool to retrieve the orders for.\n            order_states: List of order states to filter by.\n            side: The side of the market to filter by.\n            delivery_period: The delivery period to filter by.\n            delivery_area: The delivery area to filter by.\n            tag: The tag to filter by.\n            max_nr_orders: The maximum number of orders to return.\n            page_token: The page token to use for pagination.\n\n        Returns:\n            The list of orders for that gridpool.\n\n        Raises:\n            grpc.RpcError: If an error occurs while listing the orders.\n        \"\"\"\n        gridpool_order_filer = GridpoolOrderFilter(\n            order_states=order_states,\n            side=side,\n            delivery_period=delivery_period,\n            delivery_area=delivery_area,\n            tag=tag,\n        )\n\n        pagination_params = PaginationParams(\n            page_size=max_nr_orders,\n            page_token=page_token,\n        )\n\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.ListGridpoolOrdersResponse],\n                self.stub.ListGridpoolOrders(\n                    electricity_trading_pb2.ListGridpoolOrdersRequest(\n                        gridpool_id=gridpool_id,\n                        filter=gridpool_order_filer.to_pb(),\n                        pagination_params=pagination_params.to_pb(),\n                    ),\n                    metadata=self._metadata,\n                ),\n            )\n\n            return [\n                OrderDetail.from_pb(order_detail)\n                for order_detail in response.order_details\n            ]\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while listing gridpool orders: %s\", e)\n            raise e\n\n    async def list_gridpool_trades(  # pylint: disable=too-many-arguments\n        self,\n        gridpool_id: int,\n        trade_states: list[TradeState] | None = None,\n        trade_ids: list[int] | None = None,\n        market_side: MarketSide | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        delivery_area: DeliveryArea | None = None,\n        max_nr_orders: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; list[Trade]:\n        \"\"\"\n        List trades for a specific Gridpool with optional filters.\n\n        Args:\n            gridpool_id: The Gridpool to retrieve the trades for.\n            trade_states: List of trade states to filter by.\n            trade_ids: List of trade IDs to filter by.\n            market_side: The side of the market to filter by.\n            delivery_period: The delivery period to filter by.\n            delivery_area: The delivery area to filter by.\n            max_nr_orders: The maximum number of orders to return.\n            page_token: The page token to use for pagination.\n\n        Returns:\n            The list of trades for the given gridpool.\n\n        Raises:\n            grpc.RpcError: If an error occurs while listing gridpool trades.\n        \"\"\"\n        gridpool_trade_filter = GridpoolTradeFilter(\n            trade_states=trade_states,\n            trade_ids=trade_ids,\n            side=market_side,\n            delivery_period=delivery_period,\n            delivery_area=delivery_area,\n        )\n\n        pagination_params = PaginationParams(\n            page_size=max_nr_orders,\n            page_token=page_token,\n        )\n\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.ListGridpoolTradesResponse],\n                self.stub.ListGridpoolTrades(\n                    electricity_trading_pb2.ListGridpoolTradesRequest(\n                        gridpool_id=gridpool_id,\n                        filter=gridpool_trade_filter.to_pb(),\n                        pagination_params=pagination_params.to_pb(),\n                    ),\n                    metadata=self._metadata,\n                ),\n            )\n\n            return [Trade.from_pb(trade) for trade in response.trades]\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while listing gridpool trades: %s\", e)\n            raise e\n\n    async def list_public_trades(  # pylint: disable=too-many-arguments\n        self,\n        states: list[TradeState] | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        buy_delivery_area: DeliveryArea | None = None,\n        sell_delivery_area: DeliveryArea | None = None,\n        max_nr_orders: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; list[PublicTrade]:\n        \"\"\"\n        List all executed public orders with optional filters.\n\n        Args:\n            states: List of order states to filter by.\n            delivery_period: The delivery period to filter by.\n            buy_delivery_area: The buy delivery area to filter by.\n            sell_delivery_area: The sell delivery area to filter by.\n            max_nr_orders: The maximum number of orders to return.\n            page_token: The page token to use for pagination.\n\n        Returns:\n            The list of public trades.\n\n        Raises:\n            grpc.RpcError: If an error occurs while listing public trades.\n        \"\"\"\n        public_trade_filter = PublicTradeFilter(\n            states=states,\n            delivery_period=delivery_period,\n            buy_delivery_area=buy_delivery_area,\n            sell_delivery_area=sell_delivery_area,\n        )\n\n        pagination_params = PaginationParams(\n            page_size=max_nr_orders,\n            page_token=page_token,\n        )\n\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.ListPublicTradesResponse],\n                self.stub.ListPublicTrades(\n                    electricity_trading_pb2.ListPublicTradesRequest(\n                        filter=public_trade_filter.to_pb(),\n                        pagination_params=pagination_params.to_pb(),\n                    ),\n                    metadata=self._metadata,\n                ),\n            )\n\n            return [\n                PublicTrade.from_pb(public_trade)\n                for public_trade in response.public_trades\n            ]\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while listing public trades: %s\", e)\n            raise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.channel","title":"channel  <code>property</code>","text":"<pre><code>channel: ChannelT\n</code></pre> <p>The underlying gRPC channel used to communicate with the server.</p> Warning <p>This channel is provided as a last resort for advanced users. It is not recommended to use this property directly unless you know what you are doing and you don't care about being tied to a specific gRPC library.</p> RAISES DESCRIPTION <code>ClientNotConnected</code> <p>If the client is not connected to the server.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Whether the client is connected to the server.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.server_url","title":"server_url  <code>property</code>","text":"<pre><code>server_url: str\n</code></pre> <p>The URL of the server.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stub","title":"stub  <code>property</code>","text":"<pre><code>stub: StubT\n</code></pre> <p>The underlying gRPC stub.</p> Warning <p>This stub is provided as a last resort for advanced users. It is not recommended to use this property directly unless you know what you are doing and you don't care about being tied to a specific gRPC library.</p> RAISES DESCRIPTION <code>ClientNotConnected</code> <p>If the client is not connected to the server.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter a context manager.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter a context manager.\"\"\"\n    self.connect()\n    return self\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: Any | None,\n) -&gt; bool | None\n</code></pre> <p>Exit a context manager.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def __aexit__(\n    self,\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: Any | None,\n) -&gt; bool | None:\n    \"\"\"Exit a context manager.\"\"\"\n    if self._channel is None:\n        return None\n    # We need to ignore the return type here because the __aexit__ method of grpclib\n    # is not annotated correctly, it is annotated to return None but __aexit__\n    # should return a bool | None. This should be harmless if grpclib never handle\n    # any exceptions in __aexit__, so it is just a type checker issue. This is the\n    # error produced by mypy:\n    # Function does not return a value (it only ever returns None)\n    # [func-returns-value]\n    # See https://github.com/vmagamedov/grpclib/issues/193 for more details.\n    result = await self._channel.__aexit__(_exc_type, _exc_val, _exc_tb)\n    self._channel = None\n    self._stub = None\n    return result\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.__init__","title":"__init__","text":"<pre><code>__init__(\n    server_url: str,\n    connect: bool = True,\n    auth_key: str | None = None,\n) -&gt; None\n</code></pre> <p>Initialize the client.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the Electricity Trading service.</p> <p> TYPE: <code>str</code> </p> <code>connect</code> <p>Whether to connect to the server immediately.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>auth_key</code> <p>The API key for the authorization.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>def __init__(\n    self, server_url: str, connect: bool = True, auth_key: str | None = None\n) -&gt; None:\n    \"\"\"Initialize the client.\n\n    Args:\n        server_url: The URL of the Electricity Trading service.\n        connect: Whether to connect to the server immediately.\n        auth_key: The API key for the authorization.\n    \"\"\"\n    super().__init__(\n        server_url, ElectricityTradingServiceStub, grpc.aio.Channel, connect=connect\n    )\n\n    self._gridpool_orders_streams: dict[\n        tuple[int, GridpoolOrderFilter],\n        GrpcStreamBroadcaster[\n            electricity_trading_pb2.ReceiveGridpoolOrdersStreamResponse, OrderDetail\n        ],\n    ] = {}\n\n    self._gridpool_trades_streams: dict[\n        tuple[int, GridpoolTradeFilter],\n        GrpcStreamBroadcaster[\n            electricity_trading_pb2.ReceiveGridpoolTradesStreamResponse, Trade\n        ],\n    ] = {}\n\n    self._public_trades_streams: dict[\n        PublicTradeFilter,\n        GrpcStreamBroadcaster[\n            electricity_trading_pb2.ReceivePublicTradesStreamResponse, PublicTrade\n        ],\n    ] = {}\n\n    self._metadata = ((\"key\", auth_key),) if auth_key else ()\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.cancel_all_gridpool_orders","title":"cancel_all_gridpool_orders  <code>async</code>","text":"<pre><code>cancel_all_gridpool_orders(gridpool_id: int) -&gt; int\n</code></pre> <p>Cancel all orders for a specific Gridpool.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to cancel the orders for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The ID of the Gridpool for which the orders were cancelled.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while cancelling all gridpool orders.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def cancel_all_gridpool_orders(self, gridpool_id: int) -&gt; int:\n    \"\"\"\n    Cancel all orders for a specific Gridpool.\n\n    Args:\n        gridpool_id: The Gridpool to cancel the orders for.\n\n    Returns:\n        The ID of the Gridpool for which the orders were cancelled.\n\n    Raises:\n        grpc.RpcError: If an error occurs while cancelling all gridpool orders.\n    \"\"\"\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.CancelAllGridpoolOrdersResponse],\n            self.stub.CancelAllGridpoolOrders(\n                electricity_trading_pb2.CancelAllGridpoolOrdersRequest(\n                    gridpool_id=gridpool_id\n                ),\n                metadata=self._metadata,\n            ),\n        )\n\n        return response.gridpool_id\n    except grpc.RpcError as e:\n        _logger.exception(\n            \"Error occurred while cancelling all gridpool orders: %s\", e\n        )\n        raise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.cancel_gridpool_order","title":"cancel_gridpool_order  <code>async</code>","text":"<pre><code>cancel_gridpool_order(\n    gridpool_id: int, order_id: int\n) -&gt; OrderDetail\n</code></pre> <p>Cancel a single order for a given Gridpool.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to cancel the order for.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>The order to cancel.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The cancelled order.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while cancelling the gridpool order.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def cancel_gridpool_order(\n    self, gridpool_id: int, order_id: int\n) -&gt; OrderDetail:\n    \"\"\"\n    Cancel a single order for a given Gridpool.\n\n    Args:\n        gridpool_id: The Gridpool to cancel the order for.\n        order_id: The order to cancel.\n\n    Returns:\n        The cancelled order.\n\n    Raises:\n        grpc.RpcError: If an error occurs while cancelling the gridpool order.\n    \"\"\"\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.CancelGridpoolOrderResponse],\n            self.stub.CancelGridpoolOrder(\n                electricity_trading_pb2.CancelGridpoolOrderRequest(\n                    gridpool_id=gridpool_id, order_id=order_id\n                ),\n                metadata=self._metadata,\n            ),\n        )\n        return OrderDetail.from_pb(response.order_detail)\n    except grpc.RpcError as e:\n        _logger.exception(\"Error occurred while cancelling gridpool order: %s\", e)\n        raise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.connect","title":"connect","text":"<pre><code>connect(server_url: str | None = None) -&gt; None\n</code></pre> <p>Connect to the server, possibly using a new URL.</p> <p>If the client is already connected and the URL is the same as the previous URL, this method does nothing. If you want to force a reconnection, you can call disconnect() first.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server to connect to. If not provided, the previously used URL is used.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>def connect(self, server_url: str | None = None) -&gt; None:\n    \"\"\"Connect to the server, possibly using a new URL.\n\n    If the client is already connected and the URL is the same as the previous URL,\n    this method does nothing. If you want to force a reconnection, you can call\n    [disconnect()][frequenz.client.base.client.BaseApiClient.disconnect] first.\n\n    Args:\n        server_url: The URL of the server to connect to. If not provided, the\n            previously used URL is used.\n    \"\"\"\n    if server_url is not None and server_url != self._server_url:  # URL changed\n        self._server_url = server_url\n    elif self.is_connected:\n        return\n    self._channel = parse_grpc_uri(self._server_url, self._channel_type)\n    self._stub = self._create_stub(self._channel)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.create_gridpool_order","title":"create_gridpool_order  <code>async</code>","text":"<pre><code>create_gridpool_order(\n    gridpool_id: int,\n    delivery_area: DeliveryArea,\n    delivery_period: DeliveryPeriod,\n    order_type: OrderType,\n    side: MarketSide,\n    price: Price,\n    quantity: Energy,\n    stop_price: Price | None = None,\n    peak_price_delta: Price | None = None,\n    display_quantity: Energy | None = None,\n    execution_option: OrderExecutionOption | None = None,\n    valid_until: datetime | None = None,\n    payload: dict[str, Value] | None = None,\n    tag: str | None = None,\n) -&gt; OrderDetail\n</code></pre> <p>Create a gridpool order.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>ID of the gridpool to create the order for.</p> <p> TYPE: <code>int</code> </p> <code>delivery_area</code> <p>Delivery area of the order.</p> <p> TYPE: <code>DeliveryArea</code> </p> <code>delivery_period</code> <p>Delivery period of the order.</p> <p> TYPE: <code>DeliveryPeriod</code> </p> <code>order_type</code> <p>Type of the order.</p> <p> TYPE: <code>OrderType</code> </p> <code>side</code> <p>Side of the order.</p> <p> TYPE: <code>MarketSide</code> </p> <code>price</code> <p>Price of the order.</p> <p> TYPE: <code>Price</code> </p> <code>quantity</code> <p>Quantity of the order.</p> <p> TYPE: <code>Energy</code> </p> <code>stop_price</code> <p>Stop price of the order.</p> <p> TYPE: <code>Price | None</code> DEFAULT: <code>None</code> </p> <code>peak_price_delta</code> <p>Peak price delta of the order.</p> <p> TYPE: <code>Price | None</code> DEFAULT: <code>None</code> </p> <code>display_quantity</code> <p>Display quantity of the order.</p> <p> TYPE: <code>Energy | None</code> DEFAULT: <code>None</code> </p> <code>execution_option</code> <p>Execution option of the order.</p> <p> TYPE: <code>OrderExecutionOption | None</code> DEFAULT: <code>None</code> </p> <code>valid_until</code> <p>Valid until of the order.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>payload</code> <p>Payload of the order.</p> <p> TYPE: <code>dict[str, Value] | None</code> DEFAULT: <code>None</code> </p> <code>tag</code> <p>Tag of the order.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The created order.</p> RAISES DESCRIPTION <code>RpcError</code> <p>An error occurred while creating the order.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def create_gridpool_order(  # pylint: disable=too-many-arguments, too-many-locals\n    self,\n    gridpool_id: int,\n    delivery_area: DeliveryArea,\n    delivery_period: DeliveryPeriod,\n    order_type: OrderType,\n    side: MarketSide,\n    price: Price,\n    quantity: Energy,\n    stop_price: Price | None = None,\n    peak_price_delta: Price | None = None,\n    display_quantity: Energy | None = None,\n    execution_option: OrderExecutionOption | None = None,\n    valid_until: datetime | None = None,\n    payload: dict[str, struct_pb2.Value] | None = None,\n    tag: str | None = None,\n) -&gt; OrderDetail:\n    \"\"\"\n    Create a gridpool order.\n\n    Args:\n        gridpool_id: ID of the gridpool to create the order for.\n        delivery_area: Delivery area of the order.\n        delivery_period: Delivery period of the order.\n        order_type: Type of the order.\n        side: Side of the order.\n        price: Price of the order.\n        quantity: Quantity of the order.\n        stop_price: Stop price of the order.\n        peak_price_delta: Peak price delta of the order.\n        display_quantity: Display quantity of the order.\n        execution_option: Execution option of the order.\n        valid_until: Valid until of the order.\n        payload: Payload of the order.\n        tag: Tag of the order.\n\n    Returns:\n        The created order.\n\n    Raises:\n        grpc.RpcError: An error occurred while creating the order.\n    \"\"\"\n    validate_decimal_places(price.amount, PRECISION_DECIMAL_PRICE, \"price\")\n    validate_decimal_places(quantity.mwh, PRECISION_DECIMAL_QUANTITY, \"quantity\")\n    if stop_price is not None:\n        validate_decimal_places(\n            stop_price.amount, PRECISION_DECIMAL_PRICE, \"stop price\"\n        )\n    if peak_price_delta is not None:\n        validate_decimal_places(\n            peak_price_delta.amount, PRECISION_DECIMAL_PRICE, \"peak price delta\"\n        )\n    if display_quantity is not None:\n        validate_decimal_places(\n            display_quantity.mwh, PRECISION_DECIMAL_QUANTITY, \"display quantity\"\n        )\n\n    order = Order(\n        delivery_area=delivery_area,\n        delivery_period=delivery_period,\n        type=order_type,\n        side=side,\n        price=price,\n        quantity=quantity,\n        stop_price=stop_price,\n        peak_price_delta=peak_price_delta,\n        display_quantity=display_quantity,\n        execution_option=execution_option,\n        valid_until=valid_until,\n        payload=payload,\n        tag=tag,\n    )\n\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.CreateGridpoolOrderResponse],\n            self.stub.CreateGridpoolOrder(\n                electricity_trading_pb2.CreateGridpoolOrderRequest(\n                    gridpool_id=gridpool_id,\n                    order=order.to_pb(),\n                ),\n                metadata=self._metadata,\n            ),\n        )\n    except grpc.RpcError as e:\n        _logger.exception(\"Error occurred while creating gridpool order: %s\", e)\n        raise e\n\n    return OrderDetail.from_pb(response.order_detail)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the server.</p> <p>If the client is not connected, this method does nothing.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the server.\n\n    If the client is not connected, this method does nothing.\n    \"\"\"\n    await self.__aexit__(None, None, None)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.get_gridpool_order","title":"get_gridpool_order  <code>async</code>","text":"<pre><code>get_gridpool_order(\n    gridpool_id: int, order_id: int\n) -&gt; OrderDetail\n</code></pre> <p>Get a single order from a given gridpool.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to retrieve the order for.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>The order to retrieve.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The order.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while getting the order.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def get_gridpool_order(self, gridpool_id: int, order_id: int) -&gt; OrderDetail:\n    \"\"\"\n    Get a single order from a given gridpool.\n\n    Args:\n        gridpool_id: The Gridpool to retrieve the order for.\n        order_id: The order to retrieve.\n\n    Returns:\n        The order.\n\n    Raises:\n        grpc.RpcError: If an error occurs while getting the order.\n    \"\"\"\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.GetGridpoolOrderResponse],\n            self.stub.GetGridpoolOrder(\n                electricity_trading_pb2.GetGridpoolOrderRequest(\n                    gridpool_id=gridpool_id, order_id=order_id\n                ),\n                metadata=self._metadata,\n            ),\n        )\n\n        return OrderDetail.from_pb(response.order_detail)\n    except grpc.RpcError as e:\n        _logger.exception(\"Error occurred while getting gridpool order: %s\", e)\n        raise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.list_gridpool_orders","title":"list_gridpool_orders  <code>async</code>","text":"<pre><code>list_gridpool_orders(\n    gridpool_id: int,\n    order_states: list[OrderState] | None = None,\n    side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n    tag: str | None = None,\n    max_nr_orders: int | None = None,\n    page_token: str | None = None,\n) -&gt; list[OrderDetail]\n</code></pre> <p>List orders for a specific Gridpool with optional filters.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to retrieve the orders for.</p> <p> TYPE: <code>int</code> </p> <code>order_states</code> <p>List of order states to filter by.</p> <p> TYPE: <code>list[OrderState] | None</code> DEFAULT: <code>None</code> </p> <code>side</code> <p>The side of the market to filter by.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter by.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>The delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>tag</code> <p>The tag to filter by.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>max_nr_orders</code> <p>The maximum number of orders to return.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>page_token</code> <p>The page token to use for pagination.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[OrderDetail]</code> <p>The list of orders for that gridpool.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while listing the orders.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def list_gridpool_orders(  # pylint: disable=too-many-arguments\n    self,\n    gridpool_id: int,\n    order_states: list[OrderState] | None = None,\n    side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n    tag: str | None = None,\n    max_nr_orders: int | None = None,\n    page_token: str | None = None,\n) -&gt; list[OrderDetail]:\n    \"\"\"\n    List orders for a specific Gridpool with optional filters.\n\n    Args:\n        gridpool_id: The Gridpool to retrieve the orders for.\n        order_states: List of order states to filter by.\n        side: The side of the market to filter by.\n        delivery_period: The delivery period to filter by.\n        delivery_area: The delivery area to filter by.\n        tag: The tag to filter by.\n        max_nr_orders: The maximum number of orders to return.\n        page_token: The page token to use for pagination.\n\n    Returns:\n        The list of orders for that gridpool.\n\n    Raises:\n        grpc.RpcError: If an error occurs while listing the orders.\n    \"\"\"\n    gridpool_order_filer = GridpoolOrderFilter(\n        order_states=order_states,\n        side=side,\n        delivery_period=delivery_period,\n        delivery_area=delivery_area,\n        tag=tag,\n    )\n\n    pagination_params = PaginationParams(\n        page_size=max_nr_orders,\n        page_token=page_token,\n    )\n\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.ListGridpoolOrdersResponse],\n            self.stub.ListGridpoolOrders(\n                electricity_trading_pb2.ListGridpoolOrdersRequest(\n                    gridpool_id=gridpool_id,\n                    filter=gridpool_order_filer.to_pb(),\n                    pagination_params=pagination_params.to_pb(),\n                ),\n                metadata=self._metadata,\n            ),\n        )\n\n        return [\n            OrderDetail.from_pb(order_detail)\n            for order_detail in response.order_details\n        ]\n    except grpc.RpcError as e:\n        _logger.exception(\"Error occurred while listing gridpool orders: %s\", e)\n        raise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.list_gridpool_trades","title":"list_gridpool_trades  <code>async</code>","text":"<pre><code>list_gridpool_trades(\n    gridpool_id: int,\n    trade_states: list[TradeState] | None = None,\n    trade_ids: list[int] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n    max_nr_orders: int | None = None,\n    page_token: str | None = None,\n) -&gt; list[Trade]\n</code></pre> <p>List trades for a specific Gridpool with optional filters.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to retrieve the trades for.</p> <p> TYPE: <code>int</code> </p> <code>trade_states</code> <p>List of trade states to filter by.</p> <p> TYPE: <code>list[TradeState] | None</code> DEFAULT: <code>None</code> </p> <code>trade_ids</code> <p>List of trade IDs to filter by.</p> <p> TYPE: <code>list[int] | None</code> DEFAULT: <code>None</code> </p> <code>market_side</code> <p>The side of the market to filter by.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter by.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>The delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>max_nr_orders</code> <p>The maximum number of orders to return.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>page_token</code> <p>The page token to use for pagination.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Trade]</code> <p>The list of trades for the given gridpool.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while listing gridpool trades.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def list_gridpool_trades(  # pylint: disable=too-many-arguments\n    self,\n    gridpool_id: int,\n    trade_states: list[TradeState] | None = None,\n    trade_ids: list[int] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n    max_nr_orders: int | None = None,\n    page_token: str | None = None,\n) -&gt; list[Trade]:\n    \"\"\"\n    List trades for a specific Gridpool with optional filters.\n\n    Args:\n        gridpool_id: The Gridpool to retrieve the trades for.\n        trade_states: List of trade states to filter by.\n        trade_ids: List of trade IDs to filter by.\n        market_side: The side of the market to filter by.\n        delivery_period: The delivery period to filter by.\n        delivery_area: The delivery area to filter by.\n        max_nr_orders: The maximum number of orders to return.\n        page_token: The page token to use for pagination.\n\n    Returns:\n        The list of trades for the given gridpool.\n\n    Raises:\n        grpc.RpcError: If an error occurs while listing gridpool trades.\n    \"\"\"\n    gridpool_trade_filter = GridpoolTradeFilter(\n        trade_states=trade_states,\n        trade_ids=trade_ids,\n        side=market_side,\n        delivery_period=delivery_period,\n        delivery_area=delivery_area,\n    )\n\n    pagination_params = PaginationParams(\n        page_size=max_nr_orders,\n        page_token=page_token,\n    )\n\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.ListGridpoolTradesResponse],\n            self.stub.ListGridpoolTrades(\n                electricity_trading_pb2.ListGridpoolTradesRequest(\n                    gridpool_id=gridpool_id,\n                    filter=gridpool_trade_filter.to_pb(),\n                    pagination_params=pagination_params.to_pb(),\n                ),\n                metadata=self._metadata,\n            ),\n        )\n\n        return [Trade.from_pb(trade) for trade in response.trades]\n    except grpc.RpcError as e:\n        _logger.exception(\"Error occurred while listing gridpool trades: %s\", e)\n        raise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.list_public_trades","title":"list_public_trades  <code>async</code>","text":"<pre><code>list_public_trades(\n    states: list[TradeState] | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    buy_delivery_area: DeliveryArea | None = None,\n    sell_delivery_area: DeliveryArea | None = None,\n    max_nr_orders: int | None = None,\n    page_token: str | None = None,\n) -&gt; list[PublicTrade]\n</code></pre> <p>List all executed public orders with optional filters.</p> PARAMETER DESCRIPTION <code>states</code> <p>List of order states to filter by.</p> <p> TYPE: <code>list[TradeState] | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter by.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>buy_delivery_area</code> <p>The buy delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>sell_delivery_area</code> <p>The sell delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>max_nr_orders</code> <p>The maximum number of orders to return.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>page_token</code> <p>The page token to use for pagination.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[PublicTrade]</code> <p>The list of public trades.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while listing public trades.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def list_public_trades(  # pylint: disable=too-many-arguments\n    self,\n    states: list[TradeState] | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    buy_delivery_area: DeliveryArea | None = None,\n    sell_delivery_area: DeliveryArea | None = None,\n    max_nr_orders: int | None = None,\n    page_token: str | None = None,\n) -&gt; list[PublicTrade]:\n    \"\"\"\n    List all executed public orders with optional filters.\n\n    Args:\n        states: List of order states to filter by.\n        delivery_period: The delivery period to filter by.\n        buy_delivery_area: The buy delivery area to filter by.\n        sell_delivery_area: The sell delivery area to filter by.\n        max_nr_orders: The maximum number of orders to return.\n        page_token: The page token to use for pagination.\n\n    Returns:\n        The list of public trades.\n\n    Raises:\n        grpc.RpcError: If an error occurs while listing public trades.\n    \"\"\"\n    public_trade_filter = PublicTradeFilter(\n        states=states,\n        delivery_period=delivery_period,\n        buy_delivery_area=buy_delivery_area,\n        sell_delivery_area=sell_delivery_area,\n    )\n\n    pagination_params = PaginationParams(\n        page_size=max_nr_orders,\n        page_token=page_token,\n    )\n\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.ListPublicTradesResponse],\n            self.stub.ListPublicTrades(\n                electricity_trading_pb2.ListPublicTradesRequest(\n                    filter=public_trade_filter.to_pb(),\n                    pagination_params=pagination_params.to_pb(),\n                ),\n                metadata=self._metadata,\n            ),\n        )\n\n        return [\n            PublicTrade.from_pb(public_trade)\n            for public_trade in response.public_trades\n        ]\n    except grpc.RpcError as e:\n        _logger.exception(\"Error occurred while listing public trades: %s\", e)\n        raise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stream_gridpool_orders","title":"stream_gridpool_orders  <code>async</code>","text":"<pre><code>stream_gridpool_orders(\n    gridpool_id: int,\n    order_states: list[OrderState] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_area: DeliveryArea | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    tag: str | None = None,\n) -&gt; Receiver[OrderDetail]\n</code></pre> <p>Stream gridpool orders.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>ID of the gridpool to stream orders for.</p> <p> TYPE: <code>int</code> </p> <code>order_states</code> <p>List of order states to filter for.</p> <p> TYPE: <code>list[OrderState] | None</code> DEFAULT: <code>None</code> </p> <code>market_side</code> <p>Market side to filter for.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>Delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>Delivery period to filter for.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>tag</code> <p>Tag to filter for.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Receiver[OrderDetail]</code> <p>Async generator of orders.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while streaming the orders.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def stream_gridpool_orders(  # pylint: disable=too-many-arguments\n    self,\n    gridpool_id: int,\n    order_states: list[OrderState] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_area: DeliveryArea | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    tag: str | None = None,\n) -&gt; Receiver[OrderDetail]:\n    \"\"\"\n    Stream gridpool orders.\n\n    Args:\n        gridpool_id: ID of the gridpool to stream orders for.\n        order_states: List of order states to filter for.\n        market_side: Market side to filter for.\n        delivery_area: Delivery area to filter for.\n        delivery_period: Delivery period to filter for.\n        tag: Tag to filter for.\n\n    Returns:\n        Async generator of orders.\n\n    Raises:\n        grpc.RpcError: If an error occurs while streaming the orders.\n    \"\"\"\n    gridpool_order_filter = GridpoolOrderFilter(\n        order_states=order_states,\n        side=market_side,\n        delivery_area=delivery_area,\n        delivery_period=delivery_period,\n        tag=tag,\n    )\n\n    stream_key = (gridpool_id, gridpool_order_filter)\n\n    if stream_key not in self._gridpool_orders_streams:\n        try:\n            self._gridpool_orders_streams[stream_key] = GrpcStreamBroadcaster(\n                f\"electricity-trading-{stream_key}\",\n                lambda: self.stub.ReceiveGridpoolOrdersStream(  # type: ignore\n                    electricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest(\n                        gridpool_id=gridpool_id,\n                        filter=gridpool_order_filter.to_pb(),\n                    ),\n                    metadata=self._metadata,\n                ),\n                lambda response: OrderDetail.from_pb(response.order_detail),\n            )\n        except grpc.RpcError as e:\n            _logger.exception(\n                \"Error occurred while streaming gridpool orders: %s\", e\n            )\n            raise e\n    return self._gridpool_orders_streams[stream_key].new_receiver()\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stream_gridpool_trades","title":"stream_gridpool_trades  <code>async</code>","text":"<pre><code>stream_gridpool_trades(\n    gridpool_id: int,\n    trade_states: list[TradeState] | None = None,\n    trade_ids: list[int] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[Trade]\n</code></pre> <p>Stream gridpool trades.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>The ID of the gridpool to stream trades for.</p> <p> TYPE: <code>int</code> </p> <code>trade_states</code> <p>List of trade states to filter for.</p> <p> TYPE: <code>list[TradeState] | None</code> DEFAULT: <code>None</code> </p> <code>trade_ids</code> <p>List of trade IDs to filter for.</p> <p> TYPE: <code>list[int] | None</code> DEFAULT: <code>None</code> </p> <code>market_side</code> <p>The market side to filter for.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter for.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>The delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Receiver[Trade]</code> <p>The gridpool trades streamer.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while streaming gridpool trades.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def stream_gridpool_trades(  # pylint: disable=too-many-arguments\n    self,\n    gridpool_id: int,\n    trade_states: list[TradeState] | None = None,\n    trade_ids: list[int] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[Trade]:\n    \"\"\"\n    Stream gridpool trades.\n\n    Args:\n        gridpool_id: The ID of the gridpool to stream trades for.\n        trade_states: List of trade states to filter for.\n        trade_ids: List of trade IDs to filter for.\n        market_side: The market side to filter for.\n        delivery_period: The delivery period to filter for.\n        delivery_area: The delivery area to filter for.\n\n    Returns:\n        The gridpool trades streamer.\n\n    Raises:\n        grpc.RpcError: If an error occurs while streaming gridpool trades.\n    \"\"\"\n    gridpool_trade_filter = GridpoolTradeFilter(\n        trade_states=trade_states,\n        trade_ids=trade_ids,\n        side=market_side,\n        delivery_period=delivery_period,\n        delivery_area=delivery_area,\n    )\n\n    stream_key = (gridpool_id, gridpool_trade_filter)\n\n    if stream_key not in self._gridpool_trades_streams:\n        try:\n            self._gridpool_trades_streams[stream_key] = GrpcStreamBroadcaster(\n                f\"electricity-trading-{stream_key}\",\n                lambda: self.stub.ReceiveGridpoolTradesStream(  # type: ignore\n                    electricity_trading_pb2.ReceiveGridpoolTradesStreamRequest(\n                        gridpool_id=gridpool_id,\n                        filter=gridpool_trade_filter.to_pb(),\n                    ),\n                    metadata=self._metadata,\n                ),\n                lambda response: Trade.from_pb(response.trade),\n            )\n        except grpc.RpcError as e:\n            _logger.exception(\n                \"Error occurred while streaming gridpool trades: %s\", e\n            )\n            raise e\n    return self._gridpool_trades_streams[stream_key].new_receiver()\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stream_public_trades","title":"stream_public_trades  <code>async</code>","text":"<pre><code>stream_public_trades(\n    states: list[TradeState] | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    buy_delivery_area: DeliveryArea | None = None,\n    sell_delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[PublicTrade]\n</code></pre> <p>Stream public trades.</p> PARAMETER DESCRIPTION <code>states</code> <p>List of order states to filter for.</p> <p> TYPE: <code>list[TradeState] | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>Delivery period to filter for.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>buy_delivery_area</code> <p>Buy delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>sell_delivery_area</code> <p>Sell delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Receiver[PublicTrade]</code> <p>Async generator of orders.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while streaming public trades.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def stream_public_trades(\n    self,\n    states: list[TradeState] | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    buy_delivery_area: DeliveryArea | None = None,\n    sell_delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[PublicTrade]:\n    \"\"\"\n    Stream public trades.\n\n    Args:\n        states: List of order states to filter for.\n        delivery_period: Delivery period to filter for.\n        buy_delivery_area: Buy delivery area to filter for.\n        sell_delivery_area: Sell delivery area to filter for.\n\n    Returns:\n        Async generator of orders.\n\n    Raises:\n        grpc.RpcError: If an error occurs while streaming public trades.\n    \"\"\"\n    public_trade_filter = PublicTradeFilter(\n        states=states,\n        delivery_period=delivery_period,\n        buy_delivery_area=buy_delivery_area,\n        sell_delivery_area=sell_delivery_area,\n    )\n\n    if public_trade_filter not in self._public_trades_streams:\n        try:\n            self._public_trades_streams[public_trade_filter] = (\n                GrpcStreamBroadcaster(\n                    f\"electricity-trading-{public_trade_filter}\",\n                    lambda: self.stub.ReceivePublicTradesStream(  # type: ignore\n                        electricity_trading_pb2.ReceivePublicTradesStreamRequest(\n                            filter=public_trade_filter.to_pb(),\n                        ),\n                        metadata=self._metadata,\n                    ),\n                    lambda response: PublicTrade.from_pb(response.public_trade),\n                )\n            )\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while streaming public trades: %s\", e)\n            raise e\n    return self._public_trades_streams[public_trade_filter].new_receiver()\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.update_gridpool_order","title":"update_gridpool_order  <code>async</code>","text":"<pre><code>update_gridpool_order(\n    gridpool_id: int,\n    order_id: int,\n    price: Price | None | _Sentinel = NO_VALUE,\n    quantity: Energy | None | _Sentinel = NO_VALUE,\n    stop_price: Price | None | _Sentinel = NO_VALUE,\n    peak_price_delta: Price | None | _Sentinel = NO_VALUE,\n    display_quantity: Energy | None | _Sentinel = NO_VALUE,\n    execution_option: (\n        OrderExecutionOption | None | _Sentinel\n    ) = NO_VALUE,\n    valid_until: datetime | None | _Sentinel = NO_VALUE,\n    payload: dict[str, Value] | None | _Sentinel = NO_VALUE,\n    tag: str | None | _Sentinel = NO_VALUE,\n) -&gt; OrderDetail\n</code></pre> <p>Update an existing order for a given Gridpool.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>ID of the Gridpool the order belongs to.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>Order ID.</p> <p> TYPE: <code>int</code> </p> <code>price</code> <p>The updated limit price at which the contract is to be traded. This is the maximum price for a BUY order or the minimum price for a SELL order.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>quantity</code> <p>The updated quantity of the contract being traded, specified in MWh.</p> <p> TYPE: <code>Energy | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>stop_price</code> <p>Applicable for STOP_LIMIT orders. This is the updated stop price that triggers the limit order.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>peak_price_delta</code> <p>Applicable for ICEBERG orders. This is the updated price difference between the peak price and the limit price.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>display_quantity</code> <p>Applicable for ICEBERG orders. This is the updated quantity of the order to be displayed in the order book.</p> <p> TYPE: <code>Energy | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>execution_option</code> <p>Updated execution options such as All or None, Fill or Kill, etc.</p> <p> TYPE: <code>OrderExecutionOption | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>valid_until</code> <p>This is an updated timestamp defining the time after which the order should be cancelled if not filled. The timestamp is in UTC.</p> <p> TYPE: <code>datetime | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>payload</code> <p>Updated user-defined payload individual to a specific order. This can be any data that the user wants to associate with the order.</p> <p> TYPE: <code>dict[str, Value] | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>tag</code> <p>Updated user-defined tag to group related orders.</p> <p> TYPE: <code>str | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The updated order.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no fields to update are provided.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def update_gridpool_order(  # pylint: disable=too-many-arguments, too-many-locals\n    self,\n    gridpool_id: int,\n    order_id: int,\n    price: Price | None | _Sentinel = NO_VALUE,\n    quantity: Energy | None | _Sentinel = NO_VALUE,\n    stop_price: Price | None | _Sentinel = NO_VALUE,\n    peak_price_delta: Price | None | _Sentinel = NO_VALUE,\n    display_quantity: Energy | None | _Sentinel = NO_VALUE,\n    execution_option: OrderExecutionOption | None | _Sentinel = NO_VALUE,\n    valid_until: datetime | None | _Sentinel = NO_VALUE,\n    payload: dict[str, struct_pb2.Value] | None | _Sentinel = NO_VALUE,\n    tag: str | None | _Sentinel = NO_VALUE,\n) -&gt; OrderDetail:\n    \"\"\"\n    Update an existing order for a given Gridpool.\n\n    Args:\n        gridpool_id: ID of the Gridpool the order belongs to.\n        order_id: Order ID.\n        price: The updated limit price at which the contract is to be traded.\n            This is the maximum price for a BUY order or the minimum price for a SELL order.\n        quantity: The updated quantity of the contract being traded, specified in MWh.\n        stop_price: Applicable for STOP_LIMIT orders. This is the updated stop price that\n            triggers the limit order.\n        peak_price_delta: Applicable for ICEBERG orders. This is the updated price difference\n            between the peak price and the limit price.\n        display_quantity: Applicable for ICEBERG orders. This is the updated quantity of the\n            order to be displayed in the order book.\n        execution_option: Updated execution options such as All or None, Fill or Kill, etc.\n        valid_until: This is an updated timestamp defining the time after which the order\n            should be cancelled if not filled. The timestamp is in UTC.\n        payload: Updated user-defined payload individual to a specific order. This can be any\n            data that the user wants to associate with the order.\n        tag: Updated user-defined tag to group related orders.\n\n    Returns:\n        The updated order.\n\n    Raises:\n        ValueError: If no fields to update are provided.\n    \"\"\"\n    if not isinstance(price, _Sentinel) and price is not None:\n        validate_decimal_places(price.amount, PRECISION_DECIMAL_PRICE, \"price\")\n    if not isinstance(quantity, _Sentinel) and quantity is not None:\n        validate_decimal_places(\n            quantity.mwh, PRECISION_DECIMAL_QUANTITY, \"quantity\"\n        )\n    if not isinstance(stop_price, _Sentinel) and stop_price is not None:\n        validate_decimal_places(\n            stop_price.amount, PRECISION_DECIMAL_PRICE, \"stop price\"\n        )\n    if not isinstance(peak_price_delta, _Sentinel) and peak_price_delta is not None:\n        validate_decimal_places(\n            peak_price_delta.amount, PRECISION_DECIMAL_PRICE, \"peak price delta\"\n        )\n    if not isinstance(display_quantity, _Sentinel) and display_quantity is not None:\n        validate_decimal_places(\n            display_quantity.mwh, PRECISION_DECIMAL_QUANTITY, \"display quantity\"\n        )\n\n    params = {\n        \"price\": price,\n        \"quantity\": quantity,\n        \"stop_price\": stop_price,\n        \"peak_price_delta\": peak_price_delta,\n        \"display_quantity\": display_quantity,\n        \"execution_option\": execution_option,\n        \"valid_until\": valid_until,\n        \"payload\": payload,\n        \"tag\": tag,\n    }\n\n    if all(value is NO_VALUE for value in params.values()):\n        raise ValueError(\"At least one field to update must be provided.\")\n\n    paths = [param for param, value in params.items() if value is not NO_VALUE]\n\n    # Field mask specifying which fields should be updated\n    # This is used so that we can update parameters with None values\n    update_mask = field_mask_pb2.FieldMask(paths=paths)\n\n    update_order_fields = UpdateOrder(\n        price=None if price is NO_VALUE else price,  # type: ignore\n        quantity=None if quantity is NO_VALUE else quantity,  # type: ignore\n        stop_price=None if stop_price is NO_VALUE else stop_price,  # type: ignore\n        peak_price_delta=(\n            None if peak_price_delta is NO_VALUE else peak_price_delta  # type: ignore\n        ),\n        display_quantity=(\n            None if display_quantity is NO_VALUE else display_quantity  # type: ignore\n        ),\n        execution_option=(\n            None if execution_option is NO_VALUE else execution_option  # type: ignore\n        ),\n        valid_until=(\n            None if valid_until is NO_VALUE else valid_until  # type: ignore\n        ),\n        payload=None if payload is NO_VALUE else payload,  # type: ignore\n        tag=None if tag is NO_VALUE else tag,  # type: ignore\n    )\n\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.UpdateGridpoolOrderResponse],\n            self.stub.UpdateGridpoolOrder(\n                electricity_trading_pb2.UpdateGridpoolOrderRequest(\n                    gridpool_id=gridpool_id,\n                    order_id=order_id,\n                    update_order_fields=update_order_fields.to_pb(),\n                    update_mask=update_mask,\n                ),\n                metadata=self._metadata,\n            ),\n        )\n        return OrderDetail.from_pb(response.order_detail)\n\n    except grpc.RpcError as e:\n        _logger.exception(\"Error occurred while updating gridpool order: %s\", e)\n        raise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency","title":"frequenz.client.electricity_trading.Currency","text":"<p>               Bases: <code>Enum</code></p> <p>List of supported currencies.</p> <p>New currencies can be added to this enum to support additional markets.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class Currency(enum.Enum):\n    \"\"\"\n    List of supported currencies.\n\n    New currencies can be added to this enum to support additional markets.\n    \"\"\"\n\n    UNSPECIFIED = price_pb2.Price.Currency.CURRENCY_UNSPECIFIED\n    \"\"\"Currency is not specified.\"\"\"\n\n    USD = price_pb2.Price.Currency.CURRENCY_USD\n\n    CAD = price_pb2.Price.Currency.CURRENCY_CAD\n\n    EUR = price_pb2.Price.Currency.CURRENCY_EUR\n\n    GBP = price_pb2.Price.Currency.CURRENCY_GBP\n\n    CHF = price_pb2.Price.Currency.CURRENCY_CHF\n\n    CNY = price_pb2.Price.Currency.CURRENCY_CNY\n\n    JPY = price_pb2.Price.Currency.CURRENCY_JPY\n\n    AUD = price_pb2.Price.Currency.CURRENCY_AUD\n\n    NZD = price_pb2.Price.Currency.CURRENCY_NZD\n\n    SGD = price_pb2.Price.Currency.CURRENCY_SGD\n\n    @classmethod\n    def from_pb(cls, currency: price_pb2.Price.Currency.ValueType) -&gt; \"Currency\":\n        \"\"\"Convert a protobuf Currency value to Currency enum.\n\n        Args:\n            currency: Currency to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == currency for e in cls):\n            _logger.warning(\"Unknown currency %s. Returning UNSPECIFIED.\", currency)\n            return cls.UNSPECIFIED\n\n        return cls(currency)\n\n    def to_pb(self) -&gt; price_pb2.Price.Currency.ValueType:\n        \"\"\"Convert a Currency object to protobuf Currency.\n\n        Returns:\n            Protobuf message corresponding to the Currency object.\n        \"\"\"\n        return price_pb2.Price.Currency.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = CURRENCY_UNSPECIFIED\n</code></pre> <p>Currency is not specified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(currency: ValueType) -&gt; 'Currency'\n</code></pre> <p>Convert a protobuf Currency value to Currency enum.</p> PARAMETER DESCRIPTION <code>currency</code> <p>Currency to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'Currency'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, currency: price_pb2.Price.Currency.ValueType) -&gt; \"Currency\":\n    \"\"\"Convert a protobuf Currency value to Currency enum.\n\n    Args:\n        currency: Currency to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == currency for e in cls):\n        _logger.warning(\"Unknown currency %s. Returning UNSPECIFIED.\", currency)\n        return cls.UNSPECIFIED\n\n    return cls(currency)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a Currency object to protobuf Currency.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the Currency object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; price_pb2.Price.Currency.ValueType:\n    \"\"\"Convert a Currency object to protobuf Currency.\n\n    Returns:\n        Protobuf message corresponding to the Currency object.\n    \"\"\"\n    return price_pb2.Price.Currency.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea","title":"frequenz.client.electricity_trading.DeliveryArea  <code>dataclass</code>","text":"<p>Geographical or administrative region.</p> <p>These are, usually defined and maintained by a Transmission System Operator (TSO), where electricity deliveries for a contract occur.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass DeliveryArea:\n    \"\"\"\n    Geographical or administrative region.\n\n    These are, usually defined and maintained by a Transmission System Operator (TSO), where\n    electricity deliveries for a contract occur.\n    \"\"\"\n\n    code: str\n    \"\"\"Code representing the unique identifier for the delivery area.\"\"\"\n\n    code_type: EnergyMarketCodeType\n    \"\"\"Type of code used for identifying the delivery area itself.\"\"\"\n\n    @classmethod\n    def from_pb(cls, delivery_area: delivery_area_pb2.DeliveryArea) -&gt; Self:\n        \"\"\"Convert a protobuf DeliveryArea to DeliveryArea object.\n\n        Args:\n            delivery_area: DeliveryArea to convert.\n\n        Returns:\n            DeliveryArea object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            code=delivery_area.code,\n            code_type=EnergyMarketCodeType.from_pb(delivery_area.code_type),\n        )\n\n    def to_pb(self) -&gt; delivery_area_pb2.DeliveryArea:\n        \"\"\"Convert a DeliveryArea object to protobuf DeliveryArea.\n\n        Returns:\n            Protobuf message corresponding to the DeliveryArea object.\n        \"\"\"\n        return delivery_area_pb2.DeliveryArea(\n            code=self.code, code_type=self.code_type.to_pb()\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: str\n</code></pre> <p>Code representing the unique identifier for the delivery area.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.code_type","title":"code_type  <code>instance-attribute</code>","text":"<pre><code>code_type: EnergyMarketCodeType\n</code></pre> <p>Type of code used for identifying the delivery area itself.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(delivery_area: DeliveryArea) -&gt; Self\n</code></pre> <p>Convert a protobuf DeliveryArea to DeliveryArea object.</p> PARAMETER DESCRIPTION <code>delivery_area</code> <p>DeliveryArea to convert.</p> <p> TYPE: <code>DeliveryArea</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>DeliveryArea object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, delivery_area: delivery_area_pb2.DeliveryArea) -&gt; Self:\n    \"\"\"Convert a protobuf DeliveryArea to DeliveryArea object.\n\n    Args:\n        delivery_area: DeliveryArea to convert.\n\n    Returns:\n        DeliveryArea object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        code=delivery_area.code,\n        code_type=EnergyMarketCodeType.from_pb(delivery_area.code_type),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; DeliveryArea\n</code></pre> <p>Convert a DeliveryArea object to protobuf DeliveryArea.</p> RETURNS DESCRIPTION <code>DeliveryArea</code> <p>Protobuf message corresponding to the DeliveryArea object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_area_pb2.DeliveryArea:\n    \"\"\"Convert a DeliveryArea object to protobuf DeliveryArea.\n\n    Returns:\n        Protobuf message corresponding to the DeliveryArea object.\n    \"\"\"\n    return delivery_area_pb2.DeliveryArea(\n        code=self.code, code_type=self.code_type.to_pb()\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration","title":"frequenz.client.electricity_trading.DeliveryDuration","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies the time increment, in minutes, used for electricity deliveries and trading.</p> <p>These durations serve as the basis for defining the delivery period in contracts, and they dictate how energy is scheduled and delivered to meet contractual obligations.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class DeliveryDuration(enum.Enum):\n    \"\"\"\n    Specifies the time increment, in minutes, used for electricity deliveries and trading.\n\n    These durations serve as the basis for defining the delivery period in contracts, and they\n    dictate how energy is scheduled and delivered to meet contractual obligations.\n    \"\"\"\n\n    UNSPECIFIED = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_UNSPECIFIED\n    \"\"\"Default value, indicates that the duration is unspecified.\"\"\"\n\n    MINUTES_5 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_5\n    \"\"\"5-minute duration.\"\"\"\n\n    MINUTES_15 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_15\n    \"\"\"15-minute contract duration.\"\"\"\n\n    MINUTES_30 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_30\n    \"\"\"30-minute contract duration.\"\"\"\n\n    MINUTES_60 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_60\n    \"\"\"1-hour contract duration.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, delivery_duration: delivery_duration_pb2.DeliveryDuration.ValueType\n    ) -&gt; \"DeliveryDuration\":\n        \"\"\"Convert a protobuf DeliveryDuration value to DeliveryDuration enum.\n\n        Args:\n            delivery_duration: Delivery duration to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == delivery_duration for e in cls):\n            _logger.warning(\n                \"Unknown delivery duration %s. Returning UNSPECIFIED.\",\n                delivery_duration,\n            )\n            return cls.UNSPECIFIED\n\n        return cls(delivery_duration)\n\n    def to_pb(self) -&gt; delivery_duration_pb2.DeliveryDuration.ValueType:\n        \"\"\"Convert a DeliveryDuration object to protobuf DeliveryDuration.\n\n        Returns:\n            Protobuf message corresponding to the DeliveryDuration object.\n        \"\"\"\n        return delivery_duration_pb2.DeliveryDuration.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_15","title":"MINUTES_15  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_15 = DELIVERY_DURATION_15\n</code></pre> <p>15-minute contract duration.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_30","title":"MINUTES_30  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_30 = DELIVERY_DURATION_30\n</code></pre> <p>30-minute contract duration.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_5","title":"MINUTES_5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_5 = DELIVERY_DURATION_5\n</code></pre> <p>5-minute duration.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_60","title":"MINUTES_60  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_60 = DELIVERY_DURATION_60\n</code></pre> <p>1-hour contract duration.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = DELIVERY_DURATION_UNSPECIFIED\n</code></pre> <p>Default value, indicates that the duration is unspecified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(delivery_duration: ValueType) -&gt; 'DeliveryDuration'\n</code></pre> <p>Convert a protobuf DeliveryDuration value to DeliveryDuration enum.</p> PARAMETER DESCRIPTION <code>delivery_duration</code> <p>Delivery duration to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'DeliveryDuration'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, delivery_duration: delivery_duration_pb2.DeliveryDuration.ValueType\n) -&gt; \"DeliveryDuration\":\n    \"\"\"Convert a protobuf DeliveryDuration value to DeliveryDuration enum.\n\n    Args:\n        delivery_duration: Delivery duration to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == delivery_duration for e in cls):\n        _logger.warning(\n            \"Unknown delivery duration %s. Returning UNSPECIFIED.\",\n            delivery_duration,\n        )\n        return cls.UNSPECIFIED\n\n    return cls(delivery_duration)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a DeliveryDuration object to protobuf DeliveryDuration.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the DeliveryDuration object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_duration_pb2.DeliveryDuration.ValueType:\n    \"\"\"Convert a DeliveryDuration object to protobuf DeliveryDuration.\n\n    Returns:\n        Protobuf message corresponding to the DeliveryDuration object.\n    \"\"\"\n    return delivery_duration_pb2.DeliveryDuration.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod","title":"frequenz.client.electricity_trading.DeliveryPeriod","text":"<p>Time period during which the contract is delivered.</p> <p>It is defined by a start timestamp and a duration.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class DeliveryPeriod:\n    \"\"\"\n    Time period during which the contract is delivered.\n\n    It is defined by a start timestamp and a duration.\n    \"\"\"\n\n    start: datetime\n    \"\"\"Start UTC timestamp represents the beginning of the delivery period.\n        This timestamp is inclusive, meaning that the delivery period starts\n        from this point in time.\"\"\"\n\n    duration: DeliveryDuration\n    \"\"\"The length of the delivery period.\"\"\"\n\n    def __init__(\n        self,\n        start: datetime,\n        duration: timedelta,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the DeliveryPeriod object.\n\n        Args:\n            start: Start UTC timestamp represents the beginning of the delivery period.\n            duration: The length of the delivery period.\n\n        Raises:\n            ValueError: If the start timestamp does not have a timezone.\n            ValueError: If the duration is not 5, 15, 30, or 60 minutes.\n        \"\"\"\n        if start.tzinfo is None:\n            raise ValueError(\"Start timestamp must have a timezone.\")\n        if start.tzinfo != timezone.utc:\n            _logger.warning(\n                \"Start timestamp is not in UTC timezone. Converting to UTC.\"\n            )\n            start = start.astimezone(timezone.utc)\n        self.start = start\n\n        minutes = duration.total_seconds() / 60\n        match minutes:\n            case 5:\n                self.duration = DeliveryDuration.MINUTES_5\n            case 15:\n                self.duration = DeliveryDuration.MINUTES_15\n            case 30:\n                self.duration = DeliveryDuration.MINUTES_30\n            case 60:\n                self.duration = DeliveryDuration.MINUTES_60\n            case _:\n                raise ValueError(\n                    \"Invalid duration value. Duration must be 5, 15, 30, or 60 minutes.\"\n                )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Create hash of the DeliveryPeriod object.\n\n        Returns:\n            Hash of the DeliveryPeriod object.\n        \"\"\"\n        return hash((self.start, self.duration))\n\n    def __eq__(\n        self,\n        other: object,\n    ) -&gt; bool:\n        \"\"\"Check if two DeliveryPeriod objects are equal.\"\"\"\n        if not isinstance(other, DeliveryPeriod):\n            return NotImplemented\n\n        return self.start == other.start and self.duration == other.duration\n\n    @classmethod\n    def from_pb(cls, delivery_period: delivery_duration_pb2.DeliveryPeriod) -&gt; Self:\n        \"\"\"Convert a protobuf DeliveryPeriod to DeliveryPeriod object.\n\n        Args:\n            delivery_period: DeliveryPeriod to convert.\n\n        Returns:\n            DeliveryPeriod object corresponding to the protobuf message.\n\n        Raises:\n            ValueError: If the duration is not 5, 15, 30, or 60 minutes.\n        \"\"\"\n        start = delivery_period.start.ToDatetime(tzinfo=timezone.utc)\n        delivery_duration_enum = DeliveryDuration.from_pb(delivery_period.duration)\n\n        match delivery_duration_enum:\n            case DeliveryDuration.MINUTES_5:\n                duration = timedelta(minutes=5)\n            case DeliveryDuration.MINUTES_15:\n                duration = timedelta(minutes=15)\n            case DeliveryDuration.MINUTES_30:\n                duration = timedelta(minutes=30)\n            case DeliveryDuration.MINUTES_60:\n                duration = timedelta(minutes=60)\n            case _:\n                raise ValueError(\n                    \"Invalid duration value. Duration must be 5, 15, 30, or 60 minutes.\"\n                )\n        return cls(start=start, duration=duration)\n\n    def to_pb(self) -&gt; delivery_duration_pb2.DeliveryPeriod:\n        \"\"\"Convert a DeliveryPeriod object to protobuf DeliveryPeriod.\n\n        Returns:\n            Protobuf message corresponding to the DeliveryPeriod object.\n        \"\"\"\n        start = timestamp_pb2.Timestamp()\n        start.FromDatetime(self.start)\n        return delivery_duration_pb2.DeliveryPeriod(\n            start=start,\n            duration=self.duration.to_pb(),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.duration","title":"duration  <code>instance-attribute</code>","text":"<pre><code>duration: DeliveryDuration = MINUTES_60\n</code></pre> <p>The length of the delivery period.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: datetime = start\n</code></pre> <p>Start UTC timestamp represents the beginning of the delivery period. This timestamp is inclusive, meaning that the delivery period starts from this point in time.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two DeliveryPeriod objects are equal.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(\n    self,\n    other: object,\n) -&gt; bool:\n    \"\"\"Check if two DeliveryPeriod objects are equal.\"\"\"\n    if not isinstance(other, DeliveryPeriod):\n        return NotImplemented\n\n    return self.start == other.start and self.duration == other.duration\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Create hash of the DeliveryPeriod object.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of the DeliveryPeriod object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Create hash of the DeliveryPeriod object.\n\n    Returns:\n        Hash of the DeliveryPeriod object.\n    \"\"\"\n    return hash((self.start, self.duration))\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.__init__","title":"__init__","text":"<pre><code>__init__(start: datetime, duration: timedelta) -&gt; None\n</code></pre> <p>Initialize the DeliveryPeriod object.</p> PARAMETER DESCRIPTION <code>start</code> <p>Start UTC timestamp represents the beginning of the delivery period.</p> <p> TYPE: <code>datetime</code> </p> <code>duration</code> <p>The length of the delivery period.</p> <p> TYPE: <code>timedelta</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the start timestamp does not have a timezone.</p> <code>ValueError</code> <p>If the duration is not 5, 15, 30, or 60 minutes.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __init__(\n    self,\n    start: datetime,\n    duration: timedelta,\n) -&gt; None:\n    \"\"\"\n    Initialize the DeliveryPeriod object.\n\n    Args:\n        start: Start UTC timestamp represents the beginning of the delivery period.\n        duration: The length of the delivery period.\n\n    Raises:\n        ValueError: If the start timestamp does not have a timezone.\n        ValueError: If the duration is not 5, 15, 30, or 60 minutes.\n    \"\"\"\n    if start.tzinfo is None:\n        raise ValueError(\"Start timestamp must have a timezone.\")\n    if start.tzinfo != timezone.utc:\n        _logger.warning(\n            \"Start timestamp is not in UTC timezone. Converting to UTC.\"\n        )\n        start = start.astimezone(timezone.utc)\n    self.start = start\n\n    minutes = duration.total_seconds() / 60\n    match minutes:\n        case 5:\n            self.duration = DeliveryDuration.MINUTES_5\n        case 15:\n            self.duration = DeliveryDuration.MINUTES_15\n        case 30:\n            self.duration = DeliveryDuration.MINUTES_30\n        case 60:\n            self.duration = DeliveryDuration.MINUTES_60\n        case _:\n            raise ValueError(\n                \"Invalid duration value. Duration must be 5, 15, 30, or 60 minutes.\"\n            )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(delivery_period: DeliveryPeriod) -&gt; Self\n</code></pre> <p>Convert a protobuf DeliveryPeriod to DeliveryPeriod object.</p> PARAMETER DESCRIPTION <code>delivery_period</code> <p>DeliveryPeriod to convert.</p> <p> TYPE: <code>DeliveryPeriod</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>DeliveryPeriod object corresponding to the protobuf message.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the duration is not 5, 15, 30, or 60 minutes.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, delivery_period: delivery_duration_pb2.DeliveryPeriod) -&gt; Self:\n    \"\"\"Convert a protobuf DeliveryPeriod to DeliveryPeriod object.\n\n    Args:\n        delivery_period: DeliveryPeriod to convert.\n\n    Returns:\n        DeliveryPeriod object corresponding to the protobuf message.\n\n    Raises:\n        ValueError: If the duration is not 5, 15, 30, or 60 minutes.\n    \"\"\"\n    start = delivery_period.start.ToDatetime(tzinfo=timezone.utc)\n    delivery_duration_enum = DeliveryDuration.from_pb(delivery_period.duration)\n\n    match delivery_duration_enum:\n        case DeliveryDuration.MINUTES_5:\n            duration = timedelta(minutes=5)\n        case DeliveryDuration.MINUTES_15:\n            duration = timedelta(minutes=15)\n        case DeliveryDuration.MINUTES_30:\n            duration = timedelta(minutes=30)\n        case DeliveryDuration.MINUTES_60:\n            duration = timedelta(minutes=60)\n        case _:\n            raise ValueError(\n                \"Invalid duration value. Duration must be 5, 15, 30, or 60 minutes.\"\n            )\n    return cls(start=start, duration=duration)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; DeliveryPeriod\n</code></pre> <p>Convert a DeliveryPeriod object to protobuf DeliveryPeriod.</p> RETURNS DESCRIPTION <code>DeliveryPeriod</code> <p>Protobuf message corresponding to the DeliveryPeriod object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_duration_pb2.DeliveryPeriod:\n    \"\"\"Convert a DeliveryPeriod object to protobuf DeliveryPeriod.\n\n    Returns:\n        Protobuf message corresponding to the DeliveryPeriod object.\n    \"\"\"\n    start = timestamp_pb2.Timestamp()\n    start.FromDatetime(self.start)\n    return delivery_duration_pb2.DeliveryPeriod(\n        start=start,\n        duration=self.duration.to_pb(),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Energy","title":"frequenz.client.electricity_trading.Energy  <code>dataclass</code>","text":"<p>Represents energy unit in Megawatthours (MWh).</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Energy:\n    \"\"\"Represents energy unit in Megawatthours (MWh).\"\"\"\n\n    mwh: Decimal\n\n    @classmethod\n    def from_pb(cls, energy: energy_pb2.Energy) -&gt; Self:\n        \"\"\"Convert a protobuf Energy to Energy object.\n\n        Args:\n            energy: Energy to convert.\n\n        Returns:\n            Energy object corresponding to the protobuf message.\n        \"\"\"\n        return cls(mwh=Decimal(energy.mwh.value))\n\n    def to_pb(self) -&gt; energy_pb2.Energy:\n        \"\"\"Convert a Energy object to protobuf Energy.\n\n        Returns:\n            Protobuf message corresponding to the Energy object.\n        \"\"\"\n        decimal_mwh = decimal_pb2.Decimal()\n        decimal_mwh.value = str(self.mwh)\n        return energy_pb2.Energy(mwh=decimal_mwh)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Energy-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Energy.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(energy: Energy) -&gt; Self\n</code></pre> <p>Convert a protobuf Energy to Energy object.</p> PARAMETER DESCRIPTION <code>energy</code> <p>Energy to convert.</p> <p> TYPE: <code>Energy</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Energy object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, energy: energy_pb2.Energy) -&gt; Self:\n    \"\"\"Convert a protobuf Energy to Energy object.\n\n    Args:\n        energy: Energy to convert.\n\n    Returns:\n        Energy object corresponding to the protobuf message.\n    \"\"\"\n    return cls(mwh=Decimal(energy.mwh.value))\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Energy.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Energy\n</code></pre> <p>Convert a Energy object to protobuf Energy.</p> RETURNS DESCRIPTION <code>Energy</code> <p>Protobuf message corresponding to the Energy object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; energy_pb2.Energy:\n    \"\"\"Convert a Energy object to protobuf Energy.\n\n    Returns:\n        Protobuf message corresponding to the Energy object.\n    \"\"\"\n    decimal_mwh = decimal_pb2.Decimal()\n    decimal_mwh.value = str(self.mwh)\n    return energy_pb2.Energy(mwh=decimal_mwh)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType","title":"frequenz.client.electricity_trading.EnergyMarketCodeType","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies the type of identification code used in the energy market.</p> <p>This is used for uniquely identifying various entities such as delivery areas, market participants, and grid components. This enumeration aims to offer compatibility across different jurisdictional standards.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class EnergyMarketCodeType(enum.Enum):\n    \"\"\"\n    Specifies the type of identification code used in the energy market.\n\n    This is used for uniquely identifying various entities such as delivery areas, market\n    participants, and grid components. This enumeration aims to offer compatibility across\n    different jurisdictional standards.\n    \"\"\"\n\n    UNSPECIFIED = (\n        delivery_area_pb2.EnergyMarketCodeType.ENERGY_MARKET_CODE_TYPE_UNSPECIFIED\n    )\n    \"\"\"Unspecified type. This value is a placeholder and should not be used.\"\"\"\n\n    EUROPE_EIC = (\n        delivery_area_pb2.EnergyMarketCodeType.ENERGY_MARKET_CODE_TYPE_EUROPE_EIC\n    )\n    \"\"\"European Energy Identification Code Standard.\"\"\"\n\n    US_NERC = delivery_area_pb2.EnergyMarketCodeType.ENERGY_MARKET_CODE_TYPE_US_NERC\n    \"\"\"North American Electric Reliability Corporation identifiers.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, energy_market_code_type: delivery_area_pb2.EnergyMarketCodeType.ValueType\n    ) -&gt; \"EnergyMarketCodeType\":\n        \"\"\"Convert a protobuf EnergyMarketCodeType value to EnergyMarketCodeType enum.\n\n        Args:\n            energy_market_code_type: Energy market code type to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == energy_market_code_type for e in cls):\n            _logger.warning(\n                \"Unknown energy market code type %s. Returning UNSPECIFIED.\",\n                energy_market_code_type,\n            )\n            return cls.UNSPECIFIED\n\n        return cls(energy_market_code_type)\n\n    def to_pb(self) -&gt; delivery_area_pb2.EnergyMarketCodeType.ValueType:\n        \"\"\"Convert a EnergyMarketCodeType object to protobuf EnergyMarketCodeType.\n\n        Returns:\n            Protobuf message corresponding to the EnergyMarketCodeType object.\n        \"\"\"\n        return delivery_area_pb2.EnergyMarketCodeType.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.EUROPE_EIC","title":"EUROPE_EIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EUROPE_EIC = ENERGY_MARKET_CODE_TYPE_EUROPE_EIC\n</code></pre> <p>European Energy Identification Code Standard.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ENERGY_MARKET_CODE_TYPE_UNSPECIFIED\n</code></pre> <p>Unspecified type. This value is a placeholder and should not be used.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.US_NERC","title":"US_NERC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>US_NERC = ENERGY_MARKET_CODE_TYPE_US_NERC\n</code></pre> <p>North American Electric Reliability Corporation identifiers.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\n    energy_market_code_type: ValueType,\n) -&gt; \"EnergyMarketCodeType\"\n</code></pre> <p>Convert a protobuf EnergyMarketCodeType value to EnergyMarketCodeType enum.</p> PARAMETER DESCRIPTION <code>energy_market_code_type</code> <p>Energy market code type to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'EnergyMarketCodeType'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, energy_market_code_type: delivery_area_pb2.EnergyMarketCodeType.ValueType\n) -&gt; \"EnergyMarketCodeType\":\n    \"\"\"Convert a protobuf EnergyMarketCodeType value to EnergyMarketCodeType enum.\n\n    Args:\n        energy_market_code_type: Energy market code type to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == energy_market_code_type for e in cls):\n        _logger.warning(\n            \"Unknown energy market code type %s. Returning UNSPECIFIED.\",\n            energy_market_code_type,\n        )\n        return cls.UNSPECIFIED\n\n    return cls(energy_market_code_type)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a EnergyMarketCodeType object to protobuf EnergyMarketCodeType.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the EnergyMarketCodeType object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_area_pb2.EnergyMarketCodeType.ValueType:\n    \"\"\"Convert a EnergyMarketCodeType object to protobuf EnergyMarketCodeType.\n\n    Returns:\n        Protobuf message corresponding to the EnergyMarketCodeType object.\n    \"\"\"\n    return delivery_area_pb2.EnergyMarketCodeType.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter","title":"frequenz.client.electricity_trading.GridpoolOrderFilter  <code>dataclass</code>","text":"<p>Parameters for filtering Gridpool orders.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass GridpoolOrderFilter:\n    \"\"\"Parameters for filtering Gridpool orders.\"\"\"\n\n    order_states: list[OrderState] | None = None\n    \"\"\"List of order states to filter for.\"\"\"\n\n    side: MarketSide | None = None\n    \"\"\"Market side to filter for.\"\"\"\n\n    delivery_period: DeliveryPeriod | None = None\n    \"\"\"Delivery period to filter for.\"\"\"\n\n    delivery_area: DeliveryArea | None = None\n    \"\"\"Delivery area to filter for.\"\"\"\n\n    tag: str | None = None\n    \"\"\"Tag associated with the orders to be filtered.\"\"\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"\n        Check if two GridpoolOrderFilter objects are equal.\n\n        Args:\n            other: GridpoolOrderFilter object to compare with.\n\n        Returns:\n            True if the two GridpoolOrderFilter objects are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, GridpoolOrderFilter):\n            return NotImplemented\n        return (\n            self.order_states == other.order_states\n            and self.side == other.side\n            and self.delivery_period == other.delivery_period\n            and self.delivery_area == other.delivery_area\n            and self.tag == other.tag\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Create hash of the GridpoolOrderFilter object.\n\n        Returns:\n            Hash of the GridpoolOrderFilter object.\n        \"\"\"\n        return hash(\n            (\n                tuple(self.order_states) if self.order_states is not None else None,\n                self.side,\n                self.delivery_period,\n                self.delivery_area,\n                self.tag,\n            )\n        )\n\n    @classmethod\n    def from_pb(\n        cls, gridpool_order_filter: electricity_trading_pb2.GridpoolOrderFilter\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf GridpoolOrderFilter to GridpoolOrderFilter object.\n\n        Args:\n            gridpool_order_filter: GridpoolOrderFilter to convert.\n\n        Returns:\n            GridpoolOrderFilter object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            order_states=(\n                [OrderState.from_pb(state) for state in gridpool_order_filter.states]\n                if gridpool_order_filter.states\n                else None\n            ),\n            side=(\n                MarketSide.from_pb(gridpool_order_filter.side)\n                if gridpool_order_filter.HasField(\"side\")\n                else None\n            ),\n            delivery_period=(\n                DeliveryPeriod.from_pb(gridpool_order_filter.delivery_period)\n                if gridpool_order_filter.HasField(\"delivery_period\")\n                else None\n            ),\n            delivery_area=(\n                DeliveryArea.from_pb(gridpool_order_filter.delivery_area)\n                if gridpool_order_filter.HasField(\"delivery_area\")\n                else None\n            ),\n            tag=(\n                gridpool_order_filter.tag\n                if gridpool_order_filter.HasField(\"tag\")\n                else None\n            ),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.GridpoolOrderFilter:\n        \"\"\"Convert a GridpoolOrderFilter object to protobuf GridpoolOrderFilter.\n\n        Returns:\n            Protobuf GridpoolOrderFilter corresponding to the object.\n        \"\"\"\n        return electricity_trading_pb2.GridpoolOrderFilter(\n            states=(\n                [\n                    electricity_trading_pb2.OrderState.ValueType(state.value)\n                    for state in self.order_states\n                ]\n                if self.order_states\n                else None\n            ),\n            side=(\n                electricity_trading_pb2.MarketSide.ValueType(self.side.value)\n                if self.side\n                else None\n            ),\n            delivery_period=(\n                self.delivery_period.to_pb() if self.delivery_period else None\n            ),\n            delivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\n            tag=self.tag if self.tag else None,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.delivery_area","title":"delivery_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea | None = None\n</code></pre> <p>Delivery area to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.delivery_period","title":"delivery_period  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod | None = None\n</code></pre> <p>Delivery period to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.order_states","title":"order_states  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>order_states: list[OrderState] | None = None\n</code></pre> <p>List of order states to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.side","title":"side  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>side: MarketSide | None = None\n</code></pre> <p>Market side to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str | None = None\n</code></pre> <p>Tag associated with the orders to be filtered.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two GridpoolOrderFilter objects are equal.</p> PARAMETER DESCRIPTION <code>other</code> <p>GridpoolOrderFilter object to compare with.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the two GridpoolOrderFilter objects are equal, False otherwise.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Check if two GridpoolOrderFilter objects are equal.\n\n    Args:\n        other: GridpoolOrderFilter object to compare with.\n\n    Returns:\n        True if the two GridpoolOrderFilter objects are equal, False otherwise.\n    \"\"\"\n    if not isinstance(other, GridpoolOrderFilter):\n        return NotImplemented\n    return (\n        self.order_states == other.order_states\n        and self.side == other.side\n        and self.delivery_period == other.delivery_period\n        and self.delivery_area == other.delivery_area\n        and self.tag == other.tag\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Create hash of the GridpoolOrderFilter object.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of the GridpoolOrderFilter object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Create hash of the GridpoolOrderFilter object.\n\n    Returns:\n        Hash of the GridpoolOrderFilter object.\n    \"\"\"\n    return hash(\n        (\n            tuple(self.order_states) if self.order_states is not None else None,\n            self.side,\n            self.delivery_period,\n            self.delivery_area,\n            self.tag,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(gridpool_order_filter: GridpoolOrderFilter) -&gt; Self\n</code></pre> <p>Convert a protobuf GridpoolOrderFilter to GridpoolOrderFilter object.</p> PARAMETER DESCRIPTION <code>gridpool_order_filter</code> <p>GridpoolOrderFilter to convert.</p> <p> TYPE: <code>GridpoolOrderFilter</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>GridpoolOrderFilter object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, gridpool_order_filter: electricity_trading_pb2.GridpoolOrderFilter\n) -&gt; Self:\n    \"\"\"Convert a protobuf GridpoolOrderFilter to GridpoolOrderFilter object.\n\n    Args:\n        gridpool_order_filter: GridpoolOrderFilter to convert.\n\n    Returns:\n        GridpoolOrderFilter object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        order_states=(\n            [OrderState.from_pb(state) for state in gridpool_order_filter.states]\n            if gridpool_order_filter.states\n            else None\n        ),\n        side=(\n            MarketSide.from_pb(gridpool_order_filter.side)\n            if gridpool_order_filter.HasField(\"side\")\n            else None\n        ),\n        delivery_period=(\n            DeliveryPeriod.from_pb(gridpool_order_filter.delivery_period)\n            if gridpool_order_filter.HasField(\"delivery_period\")\n            else None\n        ),\n        delivery_area=(\n            DeliveryArea.from_pb(gridpool_order_filter.delivery_area)\n            if gridpool_order_filter.HasField(\"delivery_area\")\n            else None\n        ),\n        tag=(\n            gridpool_order_filter.tag\n            if gridpool_order_filter.HasField(\"tag\")\n            else None\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; GridpoolOrderFilter\n</code></pre> <p>Convert a GridpoolOrderFilter object to protobuf GridpoolOrderFilter.</p> RETURNS DESCRIPTION <code>GridpoolOrderFilter</code> <p>Protobuf GridpoolOrderFilter corresponding to the object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.GridpoolOrderFilter:\n    \"\"\"Convert a GridpoolOrderFilter object to protobuf GridpoolOrderFilter.\n\n    Returns:\n        Protobuf GridpoolOrderFilter corresponding to the object.\n    \"\"\"\n    return electricity_trading_pb2.GridpoolOrderFilter(\n        states=(\n            [\n                electricity_trading_pb2.OrderState.ValueType(state.value)\n                for state in self.order_states\n            ]\n            if self.order_states\n            else None\n        ),\n        side=(\n            electricity_trading_pb2.MarketSide.ValueType(self.side.value)\n            if self.side\n            else None\n        ),\n        delivery_period=(\n            self.delivery_period.to_pb() if self.delivery_period else None\n        ),\n        delivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\n        tag=self.tag if self.tag else None,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter","title":"frequenz.client.electricity_trading.GridpoolTradeFilter  <code>dataclass</code>","text":"<p>Parameters for filtering Gridpool trades.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass GridpoolTradeFilter:\n    \"\"\"Parameters for filtering Gridpool trades.\"\"\"\n\n    trade_states: list[TradeState] | None = None\n    \"\"\"List of trade states to filter for.\"\"\"\n\n    trade_ids: list[int] | None = None\n    \"\"\"List of trade ids to filter for.\"\"\"\n\n    side: MarketSide | None = None\n    \"\"\"Market side to filter for.\"\"\"\n\n    delivery_period: DeliveryPeriod | None = None\n    \"\"\"Delivery period to filter for.\"\"\"\n\n    delivery_area: DeliveryArea | None = None\n    \"\"\"Delivery area to filter for.\"\"\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"\n        Check if two GridpoolTradeFilter objects are equal.\n\n        Args:\n            other: GridpoolTradeFilter object to compare with.\n\n        Returns:\n            True if the two GridpoolTradeFilter objects are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, GridpoolTradeFilter):\n            return NotImplemented\n        return (\n            self.trade_states == other.trade_states\n            and self.trade_ids == other.trade_ids\n            and self.side == other.side\n            and self.delivery_period == other.delivery_period\n            and self.delivery_area == other.delivery_area\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Create hash of the GridpoolTradeFilter object.\n\n        Returns:\n            Hash of the GridpoolTradeFilter object.\n        \"\"\"\n        return hash(\n            (\n                tuple(self.trade_states) if self.trade_states is not None else None,\n                tuple(self.trade_ids) if self.trade_ids is not None else None,\n                self.side,\n                self.delivery_period,\n                self.delivery_area,\n            )\n        )\n\n    @classmethod\n    def from_pb(\n        cls, gridpool_trade_filter: electricity_trading_pb2.GridpoolTradeFilter\n    ) -&gt; \"GridpoolTradeFilter\":\n        \"\"\"Convert a protobuf GridpoolTradeFilter to GridpoolTradeFilter object.\n\n        Args:\n            gridpool_trade_filter: GridpoolTradeFilter to convert.\n\n        Returns:\n            GridpoolTradeFilter object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            trade_states=(\n                [TradeState.from_pb(state) for state in gridpool_trade_filter.states]\n                if gridpool_trade_filter.states\n                else None\n            ),\n            trade_ids=(\n                list(gridpool_trade_filter.trade_ids)\n                if gridpool_trade_filter.trade_ids\n                else None\n            ),\n            side=(\n                MarketSide.from_pb(gridpool_trade_filter.side)\n                if gridpool_trade_filter.HasField(\"side\")\n                else None\n            ),\n            delivery_period=(\n                DeliveryPeriod.from_pb(gridpool_trade_filter.delivery_period)\n                if gridpool_trade_filter.HasField(\"delivery_period\")\n                else None\n            ),\n            delivery_area=(\n                DeliveryArea.from_pb(gridpool_trade_filter.delivery_area)\n                if gridpool_trade_filter.HasField(\"delivery_area\")\n                else None\n            ),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.GridpoolTradeFilter:\n        \"\"\"\n        Convert a GridpoolTradeFilter object to protobuf GridpoolTradeFilter.\n\n        Returns:\n            Protobuf GridpoolTradeFilter corresponding to the object.\n        \"\"\"\n        return electricity_trading_pb2.GridpoolTradeFilter(\n            states=(\n                [TradeState.to_pb(state) for state in self.trade_states]\n                if self.trade_states\n                else None\n            ),\n            trade_ids=self.trade_ids if self.trade_ids else None,\n            side=MarketSide.to_pb(self.side) if self.side else None,\n            delivery_period=(\n                self.delivery_period.to_pb() if self.delivery_period else None\n            ),\n            delivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.delivery_area","title":"delivery_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea | None = None\n</code></pre> <p>Delivery area to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.delivery_period","title":"delivery_period  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod | None = None\n</code></pre> <p>Delivery period to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.side","title":"side  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>side: MarketSide | None = None\n</code></pre> <p>Market side to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.trade_ids","title":"trade_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trade_ids: list[int] | None = None\n</code></pre> <p>List of trade ids to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.trade_states","title":"trade_states  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trade_states: list[TradeState] | None = None\n</code></pre> <p>List of trade states to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two GridpoolTradeFilter objects are equal.</p> PARAMETER DESCRIPTION <code>other</code> <p>GridpoolTradeFilter object to compare with.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the two GridpoolTradeFilter objects are equal, False otherwise.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Check if two GridpoolTradeFilter objects are equal.\n\n    Args:\n        other: GridpoolTradeFilter object to compare with.\n\n    Returns:\n        True if the two GridpoolTradeFilter objects are equal, False otherwise.\n    \"\"\"\n    if not isinstance(other, GridpoolTradeFilter):\n        return NotImplemented\n    return (\n        self.trade_states == other.trade_states\n        and self.trade_ids == other.trade_ids\n        and self.side == other.side\n        and self.delivery_period == other.delivery_period\n        and self.delivery_area == other.delivery_area\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Create hash of the GridpoolTradeFilter object.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of the GridpoolTradeFilter object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Create hash of the GridpoolTradeFilter object.\n\n    Returns:\n        Hash of the GridpoolTradeFilter object.\n    \"\"\"\n    return hash(\n        (\n            tuple(self.trade_states) if self.trade_states is not None else None,\n            tuple(self.trade_ids) if self.trade_ids is not None else None,\n            self.side,\n            self.delivery_period,\n            self.delivery_area,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\n    gridpool_trade_filter: GridpoolTradeFilter,\n) -&gt; \"GridpoolTradeFilter\"\n</code></pre> <p>Convert a protobuf GridpoolTradeFilter to GridpoolTradeFilter object.</p> PARAMETER DESCRIPTION <code>gridpool_trade_filter</code> <p>GridpoolTradeFilter to convert.</p> <p> TYPE: <code>GridpoolTradeFilter</code> </p> RETURNS DESCRIPTION <code>'GridpoolTradeFilter'</code> <p>GridpoolTradeFilter object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, gridpool_trade_filter: electricity_trading_pb2.GridpoolTradeFilter\n) -&gt; \"GridpoolTradeFilter\":\n    \"\"\"Convert a protobuf GridpoolTradeFilter to GridpoolTradeFilter object.\n\n    Args:\n        gridpool_trade_filter: GridpoolTradeFilter to convert.\n\n    Returns:\n        GridpoolTradeFilter object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        trade_states=(\n            [TradeState.from_pb(state) for state in gridpool_trade_filter.states]\n            if gridpool_trade_filter.states\n            else None\n        ),\n        trade_ids=(\n            list(gridpool_trade_filter.trade_ids)\n            if gridpool_trade_filter.trade_ids\n            else None\n        ),\n        side=(\n            MarketSide.from_pb(gridpool_trade_filter.side)\n            if gridpool_trade_filter.HasField(\"side\")\n            else None\n        ),\n        delivery_period=(\n            DeliveryPeriod.from_pb(gridpool_trade_filter.delivery_period)\n            if gridpool_trade_filter.HasField(\"delivery_period\")\n            else None\n        ),\n        delivery_area=(\n            DeliveryArea.from_pb(gridpool_trade_filter.delivery_area)\n            if gridpool_trade_filter.HasField(\"delivery_area\")\n            else None\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; GridpoolTradeFilter\n</code></pre> <p>Convert a GridpoolTradeFilter object to protobuf GridpoolTradeFilter.</p> RETURNS DESCRIPTION <code>GridpoolTradeFilter</code> <p>Protobuf GridpoolTradeFilter corresponding to the object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.GridpoolTradeFilter:\n    \"\"\"\n    Convert a GridpoolTradeFilter object to protobuf GridpoolTradeFilter.\n\n    Returns:\n        Protobuf GridpoolTradeFilter corresponding to the object.\n    \"\"\"\n    return electricity_trading_pb2.GridpoolTradeFilter(\n        states=(\n            [TradeState.to_pb(state) for state in self.trade_states]\n            if self.trade_states\n            else None\n        ),\n        trade_ids=self.trade_ids if self.trade_ids else None,\n        side=MarketSide.to_pb(self.side) if self.side else None,\n        delivery_period=(\n            self.delivery_period.to_pb() if self.delivery_period else None\n        ),\n        delivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor","title":"frequenz.client.electricity_trading.MarketActor","text":"<p>               Bases: <code>Enum</code></p> <p>Actors responsible for an order state change.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class MarketActor(enum.Enum):\n    \"\"\"Actors responsible for an order state change.\"\"\"\n\n    UNSPECIFIED = (\n        electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.MARKET_ACTOR_UNSPECIFIED\n    )\n    \"\"\"The actor responsible for the state change has not been specified.\"\"\"\n\n    USER = electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.MARKET_ACTOR_USER\n    \"\"\"The user was the actor.\"\"\"\n\n    MARKET_OPERATOR = (\n        electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.MARKET_ACTOR_MARKET_OPERATOR\n    )\n    \"\"\"The market operator was the actor.\"\"\"\n\n    SYSTEM = (\n        electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.MARKET_ACTOR_SYSTEM\n    )\n    \"\"\"The system was the actor.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls,\n        market_actor: electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType,\n    ) -&gt; \"MarketActor\":\n        \"\"\"Convert a protobuf MarketActor value to MarketActor enum.\n\n        Args:\n            market_actor: Market actor to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == market_actor for e in cls):\n            _logger.warning(\n                \"Unknown market actor %s. Returning UNSPECIFIED.\", market_actor\n            )\n            return cls.UNSPECIFIED\n\n        return cls(market_actor)\n\n    def to_pb(\n        self,\n    ) -&gt; electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType:\n        \"\"\"Convert a MarketActor enum to protobuf MarketActor value.\n\n        Returns:\n            Protobuf message corresponding to the MarketActor enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.MARKET_OPERATOR","title":"MARKET_OPERATOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MARKET_OPERATOR = MARKET_ACTOR_MARKET_OPERATOR\n</code></pre> <p>The market operator was the actor.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.SYSTEM","title":"SYSTEM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYSTEM = MARKET_ACTOR_SYSTEM\n</code></pre> <p>The system was the actor.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = MARKET_ACTOR_UNSPECIFIED\n</code></pre> <p>The actor responsible for the state change has not been specified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.USER","title":"USER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>USER = MARKET_ACTOR_USER\n</code></pre> <p>The user was the actor.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(market_actor: ValueType) -&gt; 'MarketActor'\n</code></pre> <p>Convert a protobuf MarketActor value to MarketActor enum.</p> PARAMETER DESCRIPTION <code>market_actor</code> <p>Market actor to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'MarketActor'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls,\n    market_actor: electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType,\n) -&gt; \"MarketActor\":\n    \"\"\"Convert a protobuf MarketActor value to MarketActor enum.\n\n    Args:\n        market_actor: Market actor to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == market_actor for e in cls):\n        _logger.warning(\n            \"Unknown market actor %s. Returning UNSPECIFIED.\", market_actor\n        )\n        return cls.UNSPECIFIED\n\n    return cls(market_actor)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a MarketActor enum to protobuf MarketActor value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the MarketActor enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(\n    self,\n) -&gt; electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType:\n    \"\"\"Convert a MarketActor enum to protobuf MarketActor value.\n\n    Returns:\n        Protobuf message corresponding to the MarketActor enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide","title":"frequenz.client.electricity_trading.MarketSide","text":"<p>               Bases: <code>Enum</code></p> <p>Which side of the market the order is on, either buying or selling.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class MarketSide(enum.Enum):\n    \"\"\"Which side of the market the order is on, either buying or selling.\"\"\"\n\n    UNSPECIFIED = electricity_trading_pb2.MarketSide.MARKET_SIDE_UNSPECIFIED\n    \"\"\"The side of the market has not been set.\"\"\"\n\n    BUY = electricity_trading_pb2.MarketSide.MARKET_SIDE_BUY\n    \"\"\"Order to purchase electricity, referred to as a 'bid' in the order book.\"\"\"\n\n    SELL = electricity_trading_pb2.MarketSide.MARKET_SIDE_SELL\n    \"\"\"Order to sell electricity, referred to as an 'ask' or 'offer' in the order book.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, market_side: electricity_trading_pb2.MarketSide.ValueType\n    ) -&gt; \"MarketSide\":\n        \"\"\"Convert a protobuf MarketSide value to MarketSide enum.\n\n        Args:\n            market_side: Market side to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == market_side for e in cls):\n            _logger.warning(\n                \"Unknown market side %s. Returning UNSPECIFIED.\", market_side\n            )\n            return cls.UNSPECIFIED\n\n        return cls(market_side)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.MarketSide.ValueType:\n        \"\"\"Convert a MarketSide enum to protobuf MarketSide value.\n\n        Returns:\n            Protobuf message corresponding to the MarketSide enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.BUY","title":"BUY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUY = MARKET_SIDE_BUY\n</code></pre> <p>Order to purchase electricity, referred to as a 'bid' in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.SELL","title":"SELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SELL = MARKET_SIDE_SELL\n</code></pre> <p>Order to sell electricity, referred to as an 'ask' or 'offer' in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = MARKET_SIDE_UNSPECIFIED\n</code></pre> <p>The side of the market has not been set.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(market_side: ValueType) -&gt; 'MarketSide'\n</code></pre> <p>Convert a protobuf MarketSide value to MarketSide enum.</p> PARAMETER DESCRIPTION <code>market_side</code> <p>Market side to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'MarketSide'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, market_side: electricity_trading_pb2.MarketSide.ValueType\n) -&gt; \"MarketSide\":\n    \"\"\"Convert a protobuf MarketSide value to MarketSide enum.\n\n    Args:\n        market_side: Market side to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == market_side for e in cls):\n        _logger.warning(\n            \"Unknown market side %s. Returning UNSPECIFIED.\", market_side\n        )\n        return cls.UNSPECIFIED\n\n    return cls(market_side)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a MarketSide enum to protobuf MarketSide value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the MarketSide enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.MarketSide.ValueType:\n    \"\"\"Convert a MarketSide enum to protobuf MarketSide value.\n\n    Returns:\n        Protobuf message corresponding to the MarketSide enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order","title":"frequenz.client.electricity_trading.Order  <code>dataclass</code>","text":"<p>Represents an order in the electricity market.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass Order:  # pylint: disable=too-many-instance-attributes\n    \"\"\"Represents an order in the electricity market.\"\"\"\n\n    delivery_area: DeliveryArea\n    \"\"\"The delivery area where the contract is to be delivered.\"\"\"\n\n    delivery_period: DeliveryPeriod\n    \"\"\"The delivery period for the contract.\"\"\"\n\n    type: OrderType\n    \"\"\"The type of order.\"\"\"\n\n    side: MarketSide\n    \"\"\"Indicates if the order is on the Buy or Sell side of the market.\"\"\"\n\n    price: Price\n    \"\"\"The limit price at which the contract is to be traded.\"\"\"\n\n    quantity: Energy\n    \"\"\"The quantity of the contract being traded.\"\"\"\n\n    stop_price: Price | None = None\n    \"\"\"Applicable for STOP_LIMIT orders. The stop price that triggers the limit order.\"\"\"\n\n    peak_price_delta: Price | None = None\n    \"\"\"Applicable for ICEBERG orders. The price difference between the peak price and\n    the limit price.\"\"\"\n\n    display_quantity: Energy | None = None\n    \"\"\"Applicable for ICEBERG orders. The quantity of the order to be displayed in the order\n    book.\"\"\"\n\n    execution_option: OrderExecutionOption | None = None\n    \"\"\"Order execution options such as All or None, Fill or Kill, etc.\"\"\"\n\n    valid_until: datetime | None = None\n    \"\"\"UTC timestamp defining the time after which the order should be cancelled if not filled.\"\"\"\n\n    payload: dict[str, struct_pb2.Value] | None = None\n    \"\"\"User-defined payload individual to a specific order. This can be any data that needs to be\n    associated with the order.\"\"\"\n\n    tag: str | None = None\n    \"\"\"User-defined tag to group related orders.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n        if self.valid_until is not None:\n            if self.valid_until.tzinfo is None:\n                raise ValueError(\"Valid until must be a UTC datetime.\")\n            if self.valid_until.tzinfo != timezone.utc:\n                _logger.warning(\"Valid until is not a UTC datetime. Converting to UTC.\")\n                self.valid_until = self.valid_until.astimezone(timezone.utc)\n\n    @classmethod\n    def from_pb(cls, order: electricity_trading_pb2.Order) -&gt; Self:\n        \"\"\"Convert a protobuf Order to Order object.\n\n        Args:\n            order: Order to convert.\n\n        Returns:\n            Order object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            delivery_area=DeliveryArea.from_pb(order.delivery_area),\n            delivery_period=DeliveryPeriod.from_pb(order.delivery_period),\n            type=OrderType.from_pb(order.type),\n            side=MarketSide.from_pb(order.side),\n            price=Price.from_pb(order.price),\n            quantity=Energy.from_pb(order.quantity),\n            stop_price=(\n                Price.from_pb(order.stop_price)\n                if order.HasField(\"stop_price\")\n                else None\n            ),\n            peak_price_delta=(\n                Price.from_pb(order.peak_price_delta)\n                if order.HasField(\"peak_price_delta\")\n                else None\n            ),\n            display_quantity=(\n                Energy.from_pb(order.display_quantity)\n                if order.HasField(\"display_quantity\")\n                else None\n            ),\n            execution_option=(\n                OrderExecutionOption.from_pb(order.execution_option)\n                if order.HasField(\"execution_option\")\n                else None\n            ),\n            valid_until=(\n                order.valid_until.ToDatetime(tzinfo=timezone.utc)\n                if order.HasField(\"valid_until\")\n                else None\n            ),\n            payload=json_format.MessageToDict(order.payload) if order.payload else None,\n            tag=order.tag if order.tag else None,\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.Order:\n        \"\"\"\n        Convert an Order object to protobuf Order.\n\n        Returns:\n            Protobuf message corresponding to the Order object.\n        \"\"\"\n        if self.valid_until:\n            valid_until = timestamp_pb2.Timestamp()\n            valid_until.FromDatetime(self.valid_until)\n        else:\n            valid_until = None\n        return electricity_trading_pb2.Order(\n            delivery_area=self.delivery_area.to_pb(),\n            delivery_period=self.delivery_period.to_pb(),\n            type=electricity_trading_pb2.OrderType.ValueType(self.type.value),\n            side=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\n            price=self.price.to_pb(),\n            quantity=self.quantity.to_pb(),\n            stop_price=self.stop_price.to_pb() if self.stop_price else None,\n            peak_price_delta=(\n                self.peak_price_delta.to_pb() if self.peak_price_delta else None\n            ),\n            display_quantity=(\n                self.display_quantity.to_pb() if self.display_quantity else None\n            ),\n            execution_option=(\n                electricity_trading_pb2.OrderExecutionOption.ValueType(\n                    self.execution_option.value\n                )\n                if self.execution_option\n                else None\n            ),\n            valid_until=valid_until,\n            payload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\n            tag=self.tag if self.tag else None,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.delivery_area","title":"delivery_area  <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea\n</code></pre> <p>The delivery area where the contract is to be delivered.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.display_quantity","title":"display_quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>display_quantity: Energy | None = None\n</code></pre> <p>Applicable for ICEBERG orders. The quantity of the order to be displayed in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.execution_option","title":"execution_option  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execution_option: OrderExecutionOption | None = None\n</code></pre> <p>Order execution options such as All or None, Fill or Kill, etc.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.payload","title":"payload  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Value] | None = None\n</code></pre> <p>User-defined payload individual to a specific order. This can be any data that needs to be associated with the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.peak_price_delta","title":"peak_price_delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>peak_price_delta: Price | None = None\n</code></pre> <p>Applicable for ICEBERG orders. The price difference between the peak price and the limit price.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: Price\n</code></pre> <p>The limit price at which the contract is to be traded.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: Energy\n</code></pre> <p>The quantity of the contract being traded.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.side","title":"side  <code>instance-attribute</code>","text":"<pre><code>side: MarketSide\n</code></pre> <p>Indicates if the order is on the Buy or Sell side of the market.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.stop_price","title":"stop_price  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_price: Price | None = None\n</code></pre> <p>Applicable for STOP_LIMIT orders. The stop price that triggers the limit order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str | None = None\n</code></pre> <p>User-defined tag to group related orders.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: OrderType\n</code></pre> <p>The type of order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.valid_until","title":"valid_until  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>valid_until: datetime | None = None\n</code></pre> <p>UTC timestamp defining the time after which the order should be cancelled if not filled.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n    if self.valid_until is not None:\n        if self.valid_until.tzinfo is None:\n            raise ValueError(\"Valid until must be a UTC datetime.\")\n        if self.valid_until.tzinfo != timezone.utc:\n            _logger.warning(\"Valid until is not a UTC datetime. Converting to UTC.\")\n            self.valid_until = self.valid_until.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order: Order) -&gt; Self\n</code></pre> <p>Convert a protobuf Order to Order object.</p> PARAMETER DESCRIPTION <code>order</code> <p>Order to convert.</p> <p> TYPE: <code>Order</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Order object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, order: electricity_trading_pb2.Order) -&gt; Self:\n    \"\"\"Convert a protobuf Order to Order object.\n\n    Args:\n        order: Order to convert.\n\n    Returns:\n        Order object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        delivery_area=DeliveryArea.from_pb(order.delivery_area),\n        delivery_period=DeliveryPeriod.from_pb(order.delivery_period),\n        type=OrderType.from_pb(order.type),\n        side=MarketSide.from_pb(order.side),\n        price=Price.from_pb(order.price),\n        quantity=Energy.from_pb(order.quantity),\n        stop_price=(\n            Price.from_pb(order.stop_price)\n            if order.HasField(\"stop_price\")\n            else None\n        ),\n        peak_price_delta=(\n            Price.from_pb(order.peak_price_delta)\n            if order.HasField(\"peak_price_delta\")\n            else None\n        ),\n        display_quantity=(\n            Energy.from_pb(order.display_quantity)\n            if order.HasField(\"display_quantity\")\n            else None\n        ),\n        execution_option=(\n            OrderExecutionOption.from_pb(order.execution_option)\n            if order.HasField(\"execution_option\")\n            else None\n        ),\n        valid_until=(\n            order.valid_until.ToDatetime(tzinfo=timezone.utc)\n            if order.HasField(\"valid_until\")\n            else None\n        ),\n        payload=json_format.MessageToDict(order.payload) if order.payload else None,\n        tag=order.tag if order.tag else None,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Order\n</code></pre> <p>Convert an Order object to protobuf Order.</p> RETURNS DESCRIPTION <code>Order</code> <p>Protobuf message corresponding to the Order object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.Order:\n    \"\"\"\n    Convert an Order object to protobuf Order.\n\n    Returns:\n        Protobuf message corresponding to the Order object.\n    \"\"\"\n    if self.valid_until:\n        valid_until = timestamp_pb2.Timestamp()\n        valid_until.FromDatetime(self.valid_until)\n    else:\n        valid_until = None\n    return electricity_trading_pb2.Order(\n        delivery_area=self.delivery_area.to_pb(),\n        delivery_period=self.delivery_period.to_pb(),\n        type=electricity_trading_pb2.OrderType.ValueType(self.type.value),\n        side=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\n        price=self.price.to_pb(),\n        quantity=self.quantity.to_pb(),\n        stop_price=self.stop_price.to_pb() if self.stop_price else None,\n        peak_price_delta=(\n            self.peak_price_delta.to_pb() if self.peak_price_delta else None\n        ),\n        display_quantity=(\n            self.display_quantity.to_pb() if self.display_quantity else None\n        ),\n        execution_option=(\n            electricity_trading_pb2.OrderExecutionOption.ValueType(\n                self.execution_option.value\n            )\n            if self.execution_option\n            else None\n        ),\n        valid_until=valid_until,\n        payload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\n        tag=self.tag if self.tag else None,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail","title":"frequenz.client.electricity_trading.OrderDetail  <code>dataclass</code>","text":"<p>Represents an order with full details, including its ID, state, and associated UTC timestamps.</p> ATTRIBUTE DESCRIPTION <code>order_id</code> <p>Unique identifier of the order.</p> <p> TYPE: <code>int</code> </p> <code>order</code> <p>The details of the order.</p> <p> TYPE: <code>Order</code> </p> <code>state_detail</code> <p>Details of the order's current state.</p> <p> TYPE: <code>StateDetail</code> </p> <code>open_quantity</code> <p>Remaining open quantity for this order.</p> <p> TYPE: <code>Energy</code> </p> <code>filled_quantity</code> <p>Filled quantity for this order.</p> <p> TYPE: <code>Energy</code> </p> <code>create_time</code> <p>UTC Timestamp when the order was created.</p> <p> TYPE: <code>datetime</code> </p> <code>modification_time</code> <p>UTC Timestamp of the last update to the order.</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass OrderDetail:\n    \"\"\"\n    Represents an order with full details, including its ID, state, and associated UTC timestamps.\n\n    Attributes:\n        order_id: Unique identifier of the order.\n        order: The details of the order.\n        state_detail: Details of the order's current state.\n        open_quantity: Remaining open quantity for this order.\n        filled_quantity: Filled quantity for this order.\n        create_time: UTC Timestamp when the order was created.\n        modification_time: UTC Timestamp of the last update to the order.\n    \"\"\"\n\n    order_id: int\n    order: Order\n    state_detail: StateDetail\n    open_quantity: Energy\n    filled_quantity: Energy\n    create_time: datetime\n    modification_time: datetime\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"\n        Post initialization checks to ensure that all datetimes are UTC.\n\n        Raises:\n            ValueError: If create_time or modification_time do not have timezone information.\n\n        \"\"\"\n        if self.create_time.tzinfo is None:\n            raise ValueError(\"Create time must have timezone information\")\n        if self.create_time.tzinfo != timezone.utc:\n            _logger.warning(\"Create time is not in UTC timezone. Converting to UTC.\")\n            self.create_time = self.create_time.astimezone(timezone.utc)\n\n        if self.modification_time.tzinfo is None:\n            raise ValueError(\"Modification time must have timezone information\")\n        if self.modification_time.tzinfo != timezone.utc:\n            _logger.warning(\n                \"Modification time is not in UTC timezone. Converting to UTC.\"\n            )\n            self.modification_time = self.modification_time.astimezone(timezone.utc)\n\n    @classmethod\n    def from_pb(cls, order_detail: electricity_trading_pb2.OrderDetail) -&gt; Self:\n        \"\"\"Convert a protobuf OrderDetail to OrderDetail object.\n\n        Args:\n            order_detail: OrderDetail to convert.\n\n        Returns:\n            OrderDetail object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            order_id=order_detail.order_id,\n            order=Order.from_pb(order_detail.order),\n            state_detail=StateDetail.from_pb(order_detail.state_detail),\n            open_quantity=Energy.from_pb(order_detail.open_quantity),\n            filled_quantity=Energy.from_pb(order_detail.filled_quantity),\n            create_time=order_detail.create_time.ToDatetime(tzinfo=timezone.utc),\n            modification_time=order_detail.modification_time.ToDatetime(\n                tzinfo=timezone.utc\n            ),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.OrderDetail:\n        \"\"\"Convert an OrderDetail object to protobuf OrderDetail.\n\n        Returns:\n            Protobuf message corresponding to the OrderDetail object.\n        \"\"\"\n        create_time = timestamp_pb2.Timestamp()\n        create_time.FromDatetime(self.create_time)\n        modification_time = timestamp_pb2.Timestamp()\n        modification_time.FromDatetime(self.modification_time)\n\n        return electricity_trading_pb2.OrderDetail(\n            order_id=self.order_id,\n            order=self.order.to_pb(),\n            state_detail=self.state_detail.to_pb(),\n            open_quantity=self.open_quantity.to_pb(),\n            filled_quantity=self.filled_quantity.to_pb(),\n            create_time=create_time,\n            modification_time=modification_time,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If create_time or modification_time do not have timezone information.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"\n    Post initialization checks to ensure that all datetimes are UTC.\n\n    Raises:\n        ValueError: If create_time or modification_time do not have timezone information.\n\n    \"\"\"\n    if self.create_time.tzinfo is None:\n        raise ValueError(\"Create time must have timezone information\")\n    if self.create_time.tzinfo != timezone.utc:\n        _logger.warning(\"Create time is not in UTC timezone. Converting to UTC.\")\n        self.create_time = self.create_time.astimezone(timezone.utc)\n\n    if self.modification_time.tzinfo is None:\n        raise ValueError(\"Modification time must have timezone information\")\n    if self.modification_time.tzinfo != timezone.utc:\n        _logger.warning(\n            \"Modification time is not in UTC timezone. Converting to UTC.\"\n        )\n        self.modification_time = self.modification_time.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_detail: OrderDetail) -&gt; Self\n</code></pre> <p>Convert a protobuf OrderDetail to OrderDetail object.</p> PARAMETER DESCRIPTION <code>order_detail</code> <p>OrderDetail to convert.</p> <p> TYPE: <code>OrderDetail</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>OrderDetail object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, order_detail: electricity_trading_pb2.OrderDetail) -&gt; Self:\n    \"\"\"Convert a protobuf OrderDetail to OrderDetail object.\n\n    Args:\n        order_detail: OrderDetail to convert.\n\n    Returns:\n        OrderDetail object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        order_id=order_detail.order_id,\n        order=Order.from_pb(order_detail.order),\n        state_detail=StateDetail.from_pb(order_detail.state_detail),\n        open_quantity=Energy.from_pb(order_detail.open_quantity),\n        filled_quantity=Energy.from_pb(order_detail.filled_quantity),\n        create_time=order_detail.create_time.ToDatetime(tzinfo=timezone.utc),\n        modification_time=order_detail.modification_time.ToDatetime(\n            tzinfo=timezone.utc\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; OrderDetail\n</code></pre> <p>Convert an OrderDetail object to protobuf OrderDetail.</p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>Protobuf message corresponding to the OrderDetail object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderDetail:\n    \"\"\"Convert an OrderDetail object to protobuf OrderDetail.\n\n    Returns:\n        Protobuf message corresponding to the OrderDetail object.\n    \"\"\"\n    create_time = timestamp_pb2.Timestamp()\n    create_time.FromDatetime(self.create_time)\n    modification_time = timestamp_pb2.Timestamp()\n    modification_time.FromDatetime(self.modification_time)\n\n    return electricity_trading_pb2.OrderDetail(\n        order_id=self.order_id,\n        order=self.order.to_pb(),\n        state_detail=self.state_detail.to_pb(),\n        open_quantity=self.open_quantity.to_pb(),\n        filled_quantity=self.filled_quantity.to_pb(),\n        create_time=create_time,\n        modification_time=modification_time,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption","title":"frequenz.client.electricity_trading.OrderExecutionOption","text":"<p>               Bases: <code>Enum</code></p> <p>Specific behavior for the execution of an order.</p> <p>These options provide control on how an order is handled in the market.</p> <p>If no OrderExecutionOption is set, the order remains open until it's fully fulfilled, cancelled by the client, <code>valid_until</code> timestamp is reached, or the end of the trading session.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class OrderExecutionOption(enum.Enum):\n    \"\"\"\n    Specific behavior for the execution of an order.\n\n    These options provide control on how an order is handled in the market.\n\n    If no OrderExecutionOption is set, the order remains open until it's fully\n    fulfilled, cancelled by the client, `valid_until` timestamp is reached, or\n    the end of the trading session.\n    \"\"\"\n\n    UNSPECIFIED = (\n        electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_UNSPECIFIED\n    )\n    \"\"\"The order execution option has not been set.\"\"\"\n\n    AON = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_AON\n    \"\"\"All or None: Order must be executed in its entirety, or not executed at all.\"\"\"\n\n    FOK = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_FOK\n    \"\"\"Fill or Kill: Order must be executed immediately in its entirety, or not at all.\"\"\"\n\n    IOC = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_IOC\n    \"\"\"Immediate or Cancel: Any portion of an order that cannot be filled \\\n    immediately will be cancelled.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls,\n        order_execution_option: electricity_trading_pb2.OrderExecutionOption.ValueType,\n    ) -&gt; \"OrderExecutionOption\":\n        \"\"\"Convert a protobuf OrderExecutionOption value to OrderExecutionOption enum.\n\n        Args:\n            order_execution_option: order execution option to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == order_execution_option for e in OrderExecutionOption):\n            _logger.warning(\n                \"Unknown forecast feature %s. Returning UNSPECIFIED.\",\n                order_execution_option,\n            )\n            return cls.UNSPECIFIED\n\n        return OrderExecutionOption(order_execution_option)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.OrderExecutionOption.ValueType:\n        \"\"\"Convert a OrderExecutionOption object to protobuf OrderExecutionOption.\n\n        Returns:\n            Protobuf message corresponding to the OrderExecutionOption object.\n        \"\"\"\n        return electricity_trading_pb2.OrderExecutionOption.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.AON","title":"AON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AON = ORDER_EXECUTION_OPTION_AON\n</code></pre> <p>All or None: Order must be executed in its entirety, or not executed at all.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.FOK","title":"FOK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOK = ORDER_EXECUTION_OPTION_FOK\n</code></pre> <p>Fill or Kill: Order must be executed immediately in its entirety, or not at all.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.IOC","title":"IOC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IOC = ORDER_EXECUTION_OPTION_IOC\n</code></pre> <p>Immediate or Cancel: Any portion of an order that cannot be filled     immediately will be cancelled.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ORDER_EXECUTION_OPTION_UNSPECIFIED\n</code></pre> <p>The order execution option has not been set.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\n    order_execution_option: ValueType,\n) -&gt; \"OrderExecutionOption\"\n</code></pre> <p>Convert a protobuf OrderExecutionOption value to OrderExecutionOption enum.</p> PARAMETER DESCRIPTION <code>order_execution_option</code> <p>order execution option to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'OrderExecutionOption'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls,\n    order_execution_option: electricity_trading_pb2.OrderExecutionOption.ValueType,\n) -&gt; \"OrderExecutionOption\":\n    \"\"\"Convert a protobuf OrderExecutionOption value to OrderExecutionOption enum.\n\n    Args:\n        order_execution_option: order execution option to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == order_execution_option for e in OrderExecutionOption):\n        _logger.warning(\n            \"Unknown forecast feature %s. Returning UNSPECIFIED.\",\n            order_execution_option,\n        )\n        return cls.UNSPECIFIED\n\n    return OrderExecutionOption(order_execution_option)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a OrderExecutionOption object to protobuf OrderExecutionOption.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the OrderExecutionOption object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderExecutionOption.ValueType:\n    \"\"\"Convert a OrderExecutionOption object to protobuf OrderExecutionOption.\n\n    Returns:\n        Protobuf message corresponding to the OrderExecutionOption object.\n    \"\"\"\n    return electricity_trading_pb2.OrderExecutionOption.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState","title":"frequenz.client.electricity_trading.OrderState","text":"<p>               Bases: <code>Enum</code></p> <p>State of an order.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class OrderState(enum.Enum):\n    \"\"\"State of an order.\"\"\"\n\n    UNSPECIFIED = electricity_trading_pb2.OrderState.ORDER_STATE_UNSPECIFIED\n    \"\"\"The order state is not known. Usually the default state of a newly created order object\n    before any operations have been applied.\"\"\"\n\n    PENDING = electricity_trading_pb2.OrderState.ORDER_STATE_PENDING\n    \"\"\"The order has been sent to the marketplace but has not yet been confirmed. This can be due\n    to awaiting validation or system processing.\"\"\"\n\n    ACTIVE = electricity_trading_pb2.OrderState.ORDER_STATE_ACTIVE\n    \"\"\"The order has been confirmed and is open in the market. It may be unfilled or partially\n    filled.\"\"\"\n\n    FILLED = electricity_trading_pb2.OrderState.ORDER_STATE_FILLED\n    \"\"\"The order has been completely filled and there are no remaining quantities on the order.\"\"\"\n\n    CANCELED = electricity_trading_pb2.OrderState.ORDER_STATE_CANCELED\n    \"\"\"The order has been canceled. This can occur due to a cancellation request by the market\n    participant, system, or market operator.\"\"\"\n\n    EXPIRED = electricity_trading_pb2.OrderState.ORDER_STATE_EXPIRED\n    \"\"\"The order has not been filled within the defined duration and has expired.\"\"\"\n\n    FAILED = electricity_trading_pb2.OrderState.ORDER_STATE_FAILED\n    \"\"\"The order submission failed and was unable to be placed on the order book, usually due to a\n    validation error or system issue.\"\"\"\n\n    HIBERNATE = electricity_trading_pb2.OrderState.ORDER_STATE_HIBERNATE\n    \"\"\"The order has been entered into the system but is not currently exposed to the market. This\n    could be due to certain conditions not yet being met.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, order_state: electricity_trading_pb2.OrderState.ValueType\n    ) -&gt; \"OrderState\":\n        \"\"\"Convert a protobuf OrderState value to OrderState enum.\n\n        Args:\n            order_state: Order state to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == order_state for e in cls):\n            _logger.warning(\n                \"Unknown order state %s. Returning UNSPECIFIED.\", order_state\n            )\n            return cls.UNSPECIFIED\n\n        return cls(order_state)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.OrderState.ValueType:\n        \"\"\"Convert an OrderState enum to protobuf OrderState value.\n\n        Returns:\n            Protobuf message corresponding to the OrderState enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.ACTIVE","title":"ACTIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE = ORDER_STATE_ACTIVE\n</code></pre> <p>The order has been confirmed and is open in the market. It may be unfilled or partially filled.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.CANCELED","title":"CANCELED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCELED = ORDER_STATE_CANCELED\n</code></pre> <p>The order has been canceled. This can occur due to a cancellation request by the market participant, system, or market operator.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.EXPIRED","title":"EXPIRED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXPIRED = ORDER_STATE_EXPIRED\n</code></pre> <p>The order has not been filled within the defined duration and has expired.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.FAILED","title":"FAILED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAILED = ORDER_STATE_FAILED\n</code></pre> <p>The order submission failed and was unable to be placed on the order book, usually due to a validation error or system issue.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.FILLED","title":"FILLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FILLED = ORDER_STATE_FILLED\n</code></pre> <p>The order has been completely filled and there are no remaining quantities on the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.HIBERNATE","title":"HIBERNATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIBERNATE = ORDER_STATE_HIBERNATE\n</code></pre> <p>The order has been entered into the system but is not currently exposed to the market. This could be due to certain conditions not yet being met.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.PENDING","title":"PENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PENDING = ORDER_STATE_PENDING\n</code></pre> <p>The order has been sent to the marketplace but has not yet been confirmed. This can be due to awaiting validation or system processing.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ORDER_STATE_UNSPECIFIED\n</code></pre> <p>The order state is not known. Usually the default state of a newly created order object before any operations have been applied.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_state: ValueType) -&gt; 'OrderState'\n</code></pre> <p>Convert a protobuf OrderState value to OrderState enum.</p> PARAMETER DESCRIPTION <code>order_state</code> <p>Order state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'OrderState'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, order_state: electricity_trading_pb2.OrderState.ValueType\n) -&gt; \"OrderState\":\n    \"\"\"Convert a protobuf OrderState value to OrderState enum.\n\n    Args:\n        order_state: Order state to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == order_state for e in cls):\n        _logger.warning(\n            \"Unknown order state %s. Returning UNSPECIFIED.\", order_state\n        )\n        return cls.UNSPECIFIED\n\n    return cls(order_state)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert an OrderState enum to protobuf OrderState value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the OrderState enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderState.ValueType:\n    \"\"\"Convert an OrderState enum to protobuf OrderState value.\n\n    Returns:\n        Protobuf message corresponding to the OrderState enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType","title":"frequenz.client.electricity_trading.OrderType","text":"<p>               Bases: <code>Enum</code></p> <p>Type of the order (specifies how the order is to be executed in the market).</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class OrderType(enum.Enum):\n    \"\"\"Type of the order (specifies how the order is to be executed in the market).\"\"\"\n\n    UNSPECIFIED = electricity_trading_pb2.OrderType.ORDER_TYPE_UNSPECIFIED\n    \"\"\"The order type has not been set.\"\"\"\n\n    LIMIT = electricity_trading_pb2.OrderType.ORDER_TYPE_LIMIT\n    \"\"\"Order to buy or sell at a specific price or better.\n    It remains active until it is filled, cancelled, or expired.\"\"\"\n\n    STOP_LIMIT = electricity_trading_pb2.OrderType.ORDER_TYPE_STOP_LIMIT\n    \"\"\"An order that will be executed at a specified price,\n    or better, after a given stop price has been reached.\"\"\"\n\n    ICEBERG = electricity_trading_pb2.OrderType.ORDER_TYPE_ICEBERG\n    \"\"\"A large order divided into smaller lots to hide the actual order quantity.\n    Only the visible part of the order is shown in the order book.\"\"\"\n\n    BLOCK = electricity_trading_pb2.OrderType.ORDER_TYPE_BLOCK\n    \"\"\"User defined block order, generally a large quantity order filled all at once.\n    (Not yet supported).\"\"\"\n\n    BALANCE = electricity_trading_pb2.OrderType.ORDER_TYPE_BALANCE\n    \"\"\"Balance order aims to balance supply and demand, usually at\n    a specific location or within a system.(Not yet supported).\"\"\"\n\n    PREARRANGED = electricity_trading_pb2.OrderType.ORDER_TYPE_PREARRANGED\n    \"\"\"On exchange prearranged trade, a trade that has been privately\n    negotiated and then submitted to the exchange. (Not yet supported).\"\"\"\n\n    PRIVATE = electricity_trading_pb2.OrderType.ORDER_TYPE_PRIVATE\n    \"\"\"Private and confidential trade, not visible in the public\n    order book and has no market impact. (Not yet supported).\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, order_type: electricity_trading_pb2.OrderType.ValueType\n    ) -&gt; \"OrderType\":\n        \"\"\"Convert a protobuf OrderType value to OrderType enum.\n\n        Args:\n            order_type: Order type to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == order_type for e in cls):\n            _logger.warning(\"Unknown order type %s. Returning UNSPECIFIED.\", order_type)\n            return cls.UNSPECIFIED\n\n        return cls(order_type)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.OrderType.ValueType:\n        \"\"\"Convert an OrderType enum to protobuf OrderType value.\n\n        Returns:\n            Protobuf message corresponding to the OrderType enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.BALANCE","title":"BALANCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BALANCE = ORDER_TYPE_BALANCE\n</code></pre> <p>Balance order aims to balance supply and demand, usually at a specific location or within a system.(Not yet supported).</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.BLOCK","title":"BLOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLOCK = ORDER_TYPE_BLOCK\n</code></pre> <p>User defined block order, generally a large quantity order filled all at once. (Not yet supported).</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.ICEBERG","title":"ICEBERG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ICEBERG = ORDER_TYPE_ICEBERG\n</code></pre> <p>A large order divided into smaller lots to hide the actual order quantity. Only the visible part of the order is shown in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.LIMIT","title":"LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIMIT = ORDER_TYPE_LIMIT\n</code></pre> <p>Order to buy or sell at a specific price or better. It remains active until it is filled, cancelled, or expired.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.PREARRANGED","title":"PREARRANGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREARRANGED = ORDER_TYPE_PREARRANGED\n</code></pre> <p>On exchange prearranged trade, a trade that has been privately negotiated and then submitted to the exchange. (Not yet supported).</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.PRIVATE","title":"PRIVATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRIVATE = ORDER_TYPE_PRIVATE\n</code></pre> <p>Private and confidential trade, not visible in the public order book and has no market impact. (Not yet supported).</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.STOP_LIMIT","title":"STOP_LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOP_LIMIT = ORDER_TYPE_STOP_LIMIT\n</code></pre> <p>An order that will be executed at a specified price, or better, after a given stop price has been reached.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ORDER_TYPE_UNSPECIFIED\n</code></pre> <p>The order type has not been set.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_type: ValueType) -&gt; 'OrderType'\n</code></pre> <p>Convert a protobuf OrderType value to OrderType enum.</p> PARAMETER DESCRIPTION <code>order_type</code> <p>Order type to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'OrderType'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, order_type: electricity_trading_pb2.OrderType.ValueType\n) -&gt; \"OrderType\":\n    \"\"\"Convert a protobuf OrderType value to OrderType enum.\n\n    Args:\n        order_type: Order type to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == order_type for e in cls):\n        _logger.warning(\"Unknown order type %s. Returning UNSPECIFIED.\", order_type)\n        return cls.UNSPECIFIED\n\n    return cls(order_type)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert an OrderType enum to protobuf OrderType value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the OrderType enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderType.ValueType:\n    \"\"\"Convert an OrderType enum to protobuf OrderType value.\n\n    Returns:\n        Protobuf message corresponding to the OrderType enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams","title":"frequenz.client.electricity_trading.PaginationParams  <code>dataclass</code>","text":"<p>Parameters for paginating list requests.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass PaginationParams:\n    \"\"\"Parameters for paginating list requests.\"\"\"\n\n    page_size: int | None = None\n    \"\"\"The maximum number of results to be returned per request.\"\"\"\n\n    page_token: str | None = None\n    \"\"\"The token identifying a specific page of the list results.\"\"\"\n\n    @classmethod\n    def from_pb(cls, pagination_params: pagination_params_pb2.PaginationParams) -&gt; Self:\n        \"\"\"Convert a protobuf PaginationParams to PaginationParams object.\n\n        Args:\n            pagination_params: PaginationParams to convert.\n\n        Returns:\n            PaginationParams object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            page_size=pagination_params.page_size,\n            page_token=pagination_params.page_token,\n        )\n\n    def to_pb(self) -&gt; pagination_params_pb2.PaginationParams:\n        \"\"\"Convert a PaginationParams object to protobuf PaginationParams.\n\n        Returns:\n            Protobuf message corresponding to the PaginationParams object.\n        \"\"\"\n        return pagination_params_pb2.PaginationParams(\n            page_size=self.page_size,\n            page_token=self.page_token,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams.page_size","title":"page_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page_size: int | None = None\n</code></pre> <p>The maximum number of results to be returned per request.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams.page_token","title":"page_token  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page_token: str | None = None\n</code></pre> <p>The token identifying a specific page of the list results.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(pagination_params: PaginationParams) -&gt; Self\n</code></pre> <p>Convert a protobuf PaginationParams to PaginationParams object.</p> PARAMETER DESCRIPTION <code>pagination_params</code> <p>PaginationParams to convert.</p> <p> TYPE: <code>PaginationParams</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>PaginationParams object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, pagination_params: pagination_params_pb2.PaginationParams) -&gt; Self:\n    \"\"\"Convert a protobuf PaginationParams to PaginationParams object.\n\n    Args:\n        pagination_params: PaginationParams to convert.\n\n    Returns:\n        PaginationParams object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        page_size=pagination_params.page_size,\n        page_token=pagination_params.page_token,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; PaginationParams\n</code></pre> <p>Convert a PaginationParams object to protobuf PaginationParams.</p> RETURNS DESCRIPTION <code>PaginationParams</code> <p>Protobuf message corresponding to the PaginationParams object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; pagination_params_pb2.PaginationParams:\n    \"\"\"Convert a PaginationParams object to protobuf PaginationParams.\n\n    Returns:\n        Protobuf message corresponding to the PaginationParams object.\n    \"\"\"\n    return pagination_params_pb2.PaginationParams(\n        page_size=self.page_size,\n        page_token=self.page_token,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price","title":"frequenz.client.electricity_trading.Price  <code>dataclass</code>","text":"<p>Price of an order.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Price:\n    \"\"\"Price of an order.\"\"\"\n\n    amount: Decimal\n    \"\"\"Amount of the price.\"\"\"\n\n    currency: Currency\n    \"\"\"Currency of the price.\"\"\"\n\n    @classmethod\n    def from_pb(cls, price: price_pb2.Price) -&gt; Self:\n        \"\"\"Convert a protobuf Price to Price object.\n\n        Args:\n            price: Price to convert.\n\n        Returns:\n            Price object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            amount=Decimal(price.amount.value),\n            currency=Currency.from_pb(price.currency),\n        )\n\n    def to_pb(self) -&gt; price_pb2.Price:\n        \"\"\"Convert a Price object to protobuf Price.\n\n        Returns:\n            Protobuf message corresponding to the Price object.\n        \"\"\"\n        decimal_amount = decimal_pb2.Decimal()\n        decimal_amount.value = str(self.amount)\n        return price_pb2.Price(amount=decimal_amount, currency=self.currency.to_pb())\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.amount","title":"amount  <code>instance-attribute</code>","text":"<pre><code>amount: Decimal\n</code></pre> <p>Amount of the price.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.currency","title":"currency  <code>instance-attribute</code>","text":"<pre><code>currency: Currency\n</code></pre> <p>Currency of the price.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(price: Price) -&gt; Self\n</code></pre> <p>Convert a protobuf Price to Price object.</p> PARAMETER DESCRIPTION <code>price</code> <p>Price to convert.</p> <p> TYPE: <code>Price</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Price object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, price: price_pb2.Price) -&gt; Self:\n    \"\"\"Convert a protobuf Price to Price object.\n\n    Args:\n        price: Price to convert.\n\n    Returns:\n        Price object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        amount=Decimal(price.amount.value),\n        currency=Currency.from_pb(price.currency),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Price\n</code></pre> <p>Convert a Price object to protobuf Price.</p> RETURNS DESCRIPTION <code>Price</code> <p>Protobuf message corresponding to the Price object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; price_pb2.Price:\n    \"\"\"Convert a Price object to protobuf Price.\n\n    Returns:\n        Protobuf message corresponding to the Price object.\n    \"\"\"\n    decimal_amount = decimal_pb2.Decimal()\n    decimal_amount.value = str(self.amount)\n    return price_pb2.Price(amount=decimal_amount, currency=self.currency.to_pb())\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade","title":"frequenz.client.electricity_trading.PublicTrade  <code>dataclass</code>","text":"<p>Represents a public order in the market.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass PublicTrade:  # pylint: disable=too-many-instance-attributes\n    \"\"\"Represents a public order in the market.\"\"\"\n\n    public_trade_id: int\n    \"\"\"ID of the order from the public order book.\"\"\"\n\n    buy_delivery_area: DeliveryArea\n    \"\"\"Delivery area code of the buy side.\"\"\"\n\n    sell_delivery_area: DeliveryArea\n    \"\"\"Delivery area code of the sell side.\"\"\"\n\n    delivery_period: DeliveryPeriod\n    \"\"\"The delivery period for the contract.\"\"\"\n\n    execution_time: datetime\n    \"\"\"UTC Timestamp of the trades execution time.\"\"\"\n\n    price: Price\n    \"\"\"The limit price at which the contract is to be traded.\"\"\"\n\n    quantity: Energy\n    \"\"\"The quantity of the contract being traded.\"\"\"\n\n    state: TradeState\n    \"\"\"State of the order.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n        if self.execution_time.tzinfo is None:\n            raise ValueError(\"Execution time must have timezone information\")\n        if self.execution_time.tzinfo != timezone.utc:\n            _logger.warning(\"Execution time is not in UTC timezone. Converting to UTC.\")\n            self.execution_time = self.execution_time.astimezone(timezone.utc)\n\n    @classmethod\n    def from_pb(cls, public_trade: electricity_trading_pb2.PublicTrade) -&gt; Self:\n        \"\"\"Convert a protobuf PublicTrade to PublicTrade object.\n\n        Args:\n            public_trade: PublicTrade to convert.\n\n        Returns:\n            PublicTrade object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            public_trade_id=public_trade.id,\n            buy_delivery_area=DeliveryArea.from_pb(public_trade.buy_delivery_area),\n            sell_delivery_area=DeliveryArea.from_pb(public_trade.sell_delivery_area),\n            delivery_period=DeliveryPeriod.from_pb(public_trade.delivery_period),\n            execution_time=public_trade.execution_time.ToDatetime(tzinfo=timezone.utc),\n            price=Price.from_pb(public_trade.price),\n            quantity=Energy.from_pb(public_trade.quantity),\n            state=TradeState.from_pb(public_trade.state),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.PublicTrade:\n        \"\"\"Convert a PublicTrade object to protobuf PublicTrade.\n\n        Returns:\n            Protobuf message corresponding to the PublicTrade object.\n        \"\"\"\n        execution_time = timestamp_pb2.Timestamp()\n        execution_time.FromDatetime(self.execution_time)\n\n        return electricity_trading_pb2.PublicTrade(\n            id=self.public_trade_id,\n            buy_delivery_area=self.buy_delivery_area.to_pb(),\n            sell_delivery_area=self.sell_delivery_area.to_pb(),\n            delivery_period=self.delivery_period.to_pb(),\n            execution_time=execution_time,\n            price=self.price.to_pb(),\n            quantity=self.quantity.to_pb(),\n            state=electricity_trading_pb2.TradeState.ValueType(self.state.value),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.buy_delivery_area","title":"buy_delivery_area  <code>instance-attribute</code>","text":"<pre><code>buy_delivery_area: DeliveryArea\n</code></pre> <p>Delivery area code of the buy side.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.execution_time","title":"execution_time  <code>instance-attribute</code>","text":"<pre><code>execution_time: datetime\n</code></pre> <p>UTC Timestamp of the trades execution time.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: Price\n</code></pre> <p>The limit price at which the contract is to be traded.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.public_trade_id","title":"public_trade_id  <code>instance-attribute</code>","text":"<pre><code>public_trade_id: int\n</code></pre> <p>ID of the order from the public order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: Energy\n</code></pre> <p>The quantity of the contract being traded.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.sell_delivery_area","title":"sell_delivery_area  <code>instance-attribute</code>","text":"<pre><code>sell_delivery_area: DeliveryArea\n</code></pre> <p>Delivery area code of the sell side.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: TradeState\n</code></pre> <p>State of the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n    if self.execution_time.tzinfo is None:\n        raise ValueError(\"Execution time must have timezone information\")\n    if self.execution_time.tzinfo != timezone.utc:\n        _logger.warning(\"Execution time is not in UTC timezone. Converting to UTC.\")\n        self.execution_time = self.execution_time.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(public_trade: PublicTrade) -&gt; Self\n</code></pre> <p>Convert a protobuf PublicTrade to PublicTrade object.</p> PARAMETER DESCRIPTION <code>public_trade</code> <p>PublicTrade to convert.</p> <p> TYPE: <code>PublicTrade</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>PublicTrade object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, public_trade: electricity_trading_pb2.PublicTrade) -&gt; Self:\n    \"\"\"Convert a protobuf PublicTrade to PublicTrade object.\n\n    Args:\n        public_trade: PublicTrade to convert.\n\n    Returns:\n        PublicTrade object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        public_trade_id=public_trade.id,\n        buy_delivery_area=DeliveryArea.from_pb(public_trade.buy_delivery_area),\n        sell_delivery_area=DeliveryArea.from_pb(public_trade.sell_delivery_area),\n        delivery_period=DeliveryPeriod.from_pb(public_trade.delivery_period),\n        execution_time=public_trade.execution_time.ToDatetime(tzinfo=timezone.utc),\n        price=Price.from_pb(public_trade.price),\n        quantity=Energy.from_pb(public_trade.quantity),\n        state=TradeState.from_pb(public_trade.state),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; PublicTrade\n</code></pre> <p>Convert a PublicTrade object to protobuf PublicTrade.</p> RETURNS DESCRIPTION <code>PublicTrade</code> <p>Protobuf message corresponding to the PublicTrade object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.PublicTrade:\n    \"\"\"Convert a PublicTrade object to protobuf PublicTrade.\n\n    Returns:\n        Protobuf message corresponding to the PublicTrade object.\n    \"\"\"\n    execution_time = timestamp_pb2.Timestamp()\n    execution_time.FromDatetime(self.execution_time)\n\n    return electricity_trading_pb2.PublicTrade(\n        id=self.public_trade_id,\n        buy_delivery_area=self.buy_delivery_area.to_pb(),\n        sell_delivery_area=self.sell_delivery_area.to_pb(),\n        delivery_period=self.delivery_period.to_pb(),\n        execution_time=execution_time,\n        price=self.price.to_pb(),\n        quantity=self.quantity.to_pb(),\n        state=electricity_trading_pb2.TradeState.ValueType(self.state.value),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter","title":"frequenz.client.electricity_trading.PublicTradeFilter  <code>dataclass</code>","text":"<p>Parameters for filtering the historic, publicly executed orders (trades).</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass PublicTradeFilter:\n    \"\"\"Parameters for filtering the historic, publicly executed orders (trades).\"\"\"\n\n    states: list[TradeState] | None = None\n    \"\"\"List of order states to filter for.\"\"\"\n\n    delivery_period: DeliveryPeriod | None = None\n    \"\"\"Delivery period to filter for.\"\"\"\n\n    buy_delivery_area: DeliveryArea | None = None\n    \"\"\"Delivery area to filter for on the buy side.\"\"\"\n\n    sell_delivery_area: DeliveryArea | None = None\n    \"\"\"Delivery area to filter for on the sell side.\"\"\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"\n        Check if two PublicTradeFilter objects are equal.\n\n        Args:\n            other: PublicTradeFilter object to compare with.\n\n        Returns:\n            True if the two PublicTradeFilter objects are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, PublicTradeFilter):\n            return NotImplemented\n        return (\n            self.states == other.states\n            and self.delivery_period == other.delivery_period\n            and self.buy_delivery_area == other.buy_delivery_area\n            and self.sell_delivery_area == other.sell_delivery_area\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Create hash of the PublicTradeFilter object.\n\n        Returns:\n            Hash of the PublicTradeFilter object.\n        \"\"\"\n        return hash(\n            (\n                tuple(self.states) if self.states is not None else None,\n                self.delivery_period,\n                self.buy_delivery_area,\n                self.sell_delivery_area,\n            )\n        )\n\n    @classmethod\n    def from_pb(\n        cls, public_trade_filter: electricity_trading_pb2.PublicTradeFilter\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf PublicTradeFilter to PublicTradeFilter object.\n\n        Args:\n            public_trade_filter: PublicTradeFilter to convert.\n\n        Returns:\n            PublicTradeFilter object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            states=(\n                [TradeState.from_pb(state) for state in public_trade_filter.states]\n                if public_trade_filter.states\n                else None\n            ),\n            delivery_period=(\n                DeliveryPeriod.from_pb(public_trade_filter.delivery_period)\n                if public_trade_filter.HasField(\"delivery_period\")\n                else None\n            ),\n            buy_delivery_area=(\n                DeliveryArea.from_pb(public_trade_filter.buy_delivery_area)\n                if public_trade_filter.HasField(\"buy_delivery_area\")\n                else None\n            ),\n            sell_delivery_area=(\n                DeliveryArea.from_pb(public_trade_filter.sell_delivery_area)\n                if public_trade_filter.HasField(\"sell_delivery_area\")\n                else None\n            ),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.PublicTradeFilter:\n        \"\"\"Convert a PublicTradeFilter object to protobuf PublicTradeFilter.\n\n        Returns:\n            Protobuf PublicTradeFilter corresponding to the object.\n        \"\"\"\n        return electricity_trading_pb2.PublicTradeFilter(\n            states=(\n                [\n                    electricity_trading_pb2.TradeState.ValueType(state.value)\n                    for state in self.states\n                ]\n                if self.states\n                else None\n            ),\n            delivery_period=(\n                self.delivery_period.to_pb() if self.delivery_period else None\n            ),\n            buy_delivery_area=(\n                self.buy_delivery_area.to_pb() if self.buy_delivery_area else None\n            ),\n            sell_delivery_area=(\n                self.sell_delivery_area.to_pb() if self.sell_delivery_area else None\n            ),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.buy_delivery_area","title":"buy_delivery_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>buy_delivery_area: DeliveryArea | None = None\n</code></pre> <p>Delivery area to filter for on the buy side.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.delivery_period","title":"delivery_period  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod | None = None\n</code></pre> <p>Delivery period to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.sell_delivery_area","title":"sell_delivery_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sell_delivery_area: DeliveryArea | None = None\n</code></pre> <p>Delivery area to filter for on the sell side.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.states","title":"states  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>states: list[TradeState] | None = None\n</code></pre> <p>List of order states to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two PublicTradeFilter objects are equal.</p> PARAMETER DESCRIPTION <code>other</code> <p>PublicTradeFilter object to compare with.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the two PublicTradeFilter objects are equal, False otherwise.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Check if two PublicTradeFilter objects are equal.\n\n    Args:\n        other: PublicTradeFilter object to compare with.\n\n    Returns:\n        True if the two PublicTradeFilter objects are equal, False otherwise.\n    \"\"\"\n    if not isinstance(other, PublicTradeFilter):\n        return NotImplemented\n    return (\n        self.states == other.states\n        and self.delivery_period == other.delivery_period\n        and self.buy_delivery_area == other.buy_delivery_area\n        and self.sell_delivery_area == other.sell_delivery_area\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Create hash of the PublicTradeFilter object.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of the PublicTradeFilter object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Create hash of the PublicTradeFilter object.\n\n    Returns:\n        Hash of the PublicTradeFilter object.\n    \"\"\"\n    return hash(\n        (\n            tuple(self.states) if self.states is not None else None,\n            self.delivery_period,\n            self.buy_delivery_area,\n            self.sell_delivery_area,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(public_trade_filter: PublicTradeFilter) -&gt; Self\n</code></pre> <p>Convert a protobuf PublicTradeFilter to PublicTradeFilter object.</p> PARAMETER DESCRIPTION <code>public_trade_filter</code> <p>PublicTradeFilter to convert.</p> <p> TYPE: <code>PublicTradeFilter</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>PublicTradeFilter object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, public_trade_filter: electricity_trading_pb2.PublicTradeFilter\n) -&gt; Self:\n    \"\"\"Convert a protobuf PublicTradeFilter to PublicTradeFilter object.\n\n    Args:\n        public_trade_filter: PublicTradeFilter to convert.\n\n    Returns:\n        PublicTradeFilter object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        states=(\n            [TradeState.from_pb(state) for state in public_trade_filter.states]\n            if public_trade_filter.states\n            else None\n        ),\n        delivery_period=(\n            DeliveryPeriod.from_pb(public_trade_filter.delivery_period)\n            if public_trade_filter.HasField(\"delivery_period\")\n            else None\n        ),\n        buy_delivery_area=(\n            DeliveryArea.from_pb(public_trade_filter.buy_delivery_area)\n            if public_trade_filter.HasField(\"buy_delivery_area\")\n            else None\n        ),\n        sell_delivery_area=(\n            DeliveryArea.from_pb(public_trade_filter.sell_delivery_area)\n            if public_trade_filter.HasField(\"sell_delivery_area\")\n            else None\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; PublicTradeFilter\n</code></pre> <p>Convert a PublicTradeFilter object to protobuf PublicTradeFilter.</p> RETURNS DESCRIPTION <code>PublicTradeFilter</code> <p>Protobuf PublicTradeFilter corresponding to the object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.PublicTradeFilter:\n    \"\"\"Convert a PublicTradeFilter object to protobuf PublicTradeFilter.\n\n    Returns:\n        Protobuf PublicTradeFilter corresponding to the object.\n    \"\"\"\n    return electricity_trading_pb2.PublicTradeFilter(\n        states=(\n            [\n                electricity_trading_pb2.TradeState.ValueType(state.value)\n                for state in self.states\n            ]\n            if self.states\n            else None\n        ),\n        delivery_period=(\n            self.delivery_period.to_pb() if self.delivery_period else None\n        ),\n        buy_delivery_area=(\n            self.buy_delivery_area.to_pb() if self.buy_delivery_area else None\n        ),\n        sell_delivery_area=(\n            self.sell_delivery_area.to_pb() if self.sell_delivery_area else None\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail","title":"frequenz.client.electricity_trading.StateDetail  <code>dataclass</code>","text":"<p>Details about the current state of the order.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass StateDetail:\n    \"\"\"Details about the current state of the order.\"\"\"\n\n    state: OrderState\n    \"\"\"Current state of the order.\"\"\"\n\n    state_reason: StateReason\n    \"\"\"Reason for the current state.\"\"\"\n\n    market_actor: MarketActor\n    \"\"\"Actor responsible for the current state.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, state_detail: electricity_trading_pb2.OrderDetail.StateDetail\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf StateDetail to StateDetail object.\n\n        Args:\n            state_detail: StateDetail to convert.\n\n        Returns:\n            StateDetail object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            state=OrderState.from_pb(state_detail.state),\n            state_reason=StateReason.from_pb(state_detail.state_reason),\n            market_actor=MarketActor.from_pb(state_detail.market_actor),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.OrderDetail.StateDetail:\n        \"\"\"Convert a StateDetail object to protobuf StateDetail.\n\n        Returns:\n            Protobuf message corresponding to the StateDetail object.\n        \"\"\"\n        return electricity_trading_pb2.OrderDetail.StateDetail(\n            state=electricity_trading_pb2.OrderState.ValueType(self.state.value),\n            state_reason=electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType(\n                self.state_reason.value\n            ),\n            market_actor=electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType(\n                self.market_actor.value\n            ),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.market_actor","title":"market_actor  <code>instance-attribute</code>","text":"<pre><code>market_actor: MarketActor\n</code></pre> <p>Actor responsible for the current state.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: OrderState\n</code></pre> <p>Current state of the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.state_reason","title":"state_reason  <code>instance-attribute</code>","text":"<pre><code>state_reason: StateReason\n</code></pre> <p>Reason for the current state.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(state_detail: StateDetail) -&gt; Self\n</code></pre> <p>Convert a protobuf StateDetail to StateDetail object.</p> PARAMETER DESCRIPTION <code>state_detail</code> <p>StateDetail to convert.</p> <p> TYPE: <code>StateDetail</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>StateDetail object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, state_detail: electricity_trading_pb2.OrderDetail.StateDetail\n) -&gt; Self:\n    \"\"\"Convert a protobuf StateDetail to StateDetail object.\n\n    Args:\n        state_detail: StateDetail to convert.\n\n    Returns:\n        StateDetail object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        state=OrderState.from_pb(state_detail.state),\n        state_reason=StateReason.from_pb(state_detail.state_reason),\n        market_actor=MarketActor.from_pb(state_detail.market_actor),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; StateDetail\n</code></pre> <p>Convert a StateDetail object to protobuf StateDetail.</p> RETURNS DESCRIPTION <code>StateDetail</code> <p>Protobuf message corresponding to the StateDetail object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderDetail.StateDetail:\n    \"\"\"Convert a StateDetail object to protobuf StateDetail.\n\n    Returns:\n        Protobuf message corresponding to the StateDetail object.\n    \"\"\"\n    return electricity_trading_pb2.OrderDetail.StateDetail(\n        state=electricity_trading_pb2.OrderState.ValueType(self.state.value),\n        state_reason=electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType(\n            self.state_reason.value\n        ),\n        market_actor=electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType(\n            self.market_actor.value\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason","title":"frequenz.client.electricity_trading.StateReason","text":"<p>               Bases: <code>Enum</code></p> <p>Reason that led to a state change.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class StateReason(enum.Enum):\n    \"\"\"Reason that led to a state change.\"\"\"\n\n    UNSPECIFIED = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_UNSPECIFIED\n    )\n    \"\"\"The reason for the state change has not been specified.\"\"\"\n\n    ADD = electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_ADD\n    \"\"\"The order was added.\"\"\"\n\n    MODIFY = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_MODIFY\n    )\n    \"\"\"The order was modified.\"\"\"\n\n    DELETE = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_DELETE\n    )\n    \"\"\"The order was deleted.\"\"\"\n\n    DEACTIVATE = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_DEACTIVATE\n    )\n    \"\"\"The order was deactivated.\"\"\"\n\n    REJECT = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_REJECT\n    )\n    \"\"\"The order was rejected.\"\"\"\n\n    FULL_EXECUTION = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_FULL_EXECUTION\n    )\n    \"\"\"The order was fully executed.\"\"\"\n\n    PARTIAL_EXECUTION = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_PARTIAL_EXECUTION\n    )\n    \"\"\"The order was partially executed.\"\"\"\n\n    ICEBERG_SLICE_ADD = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_ICEBERG_SLICE_ADD\n    )\n    \"\"\"An iceberg slice was added.\"\"\"\n\n    VALIDATION_FAIL = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_VALIDATION_FAIL\n    )\n    \"\"\"The order failed validation.\"\"\"\n\n    UNKNOWN_STATE = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_UNKNOWN_STATE\n    )\n    \"\"\"The state of the order is unknown.\"\"\"\n\n    QUOTE_ADD = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_QUOTE_ADD\n    )\n    \"\"\"A quote was added.\"\"\"\n\n    QUOTE_FULL_EXECUTION = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_QUOTE_FULL_EXECUTION  # noqa: E501\n    )\n    \"\"\"A quote was fully executed.\"\"\"\n\n    QUOTE_PARTIAL_EXECUTION = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_QUOTE_PARTIAL_EXECUTION  # noqa: E501\n    )\n    \"\"\"A quote was partially executed.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls,\n        state_reason: electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType,\n    ) -&gt; \"StateReason\":\n        \"\"\"Convert a protobuf StateReason value to StateReason enum.\n\n        Args:\n            state_reason: State reason to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == state_reason for e in cls):\n            _logger.warning(\n                \"Unknown state reason %s. Returning UNSPECIFIED.\", state_reason\n            )\n            return cls.UNSPECIFIED\n\n        return cls(state_reason)\n\n    def to_pb(\n        self,\n    ) -&gt; electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType:\n        \"\"\"Convert a StateReason enum to protobuf StateReason value.\n\n        Returns:\n            Protobuf message corresponding to the StateReason enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.ADD","title":"ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ADD = STATE_REASON_ADD\n</code></pre> <p>The order was added.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.DEACTIVATE","title":"DEACTIVATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEACTIVATE = STATE_REASON_DEACTIVATE\n</code></pre> <p>The order was deactivated.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.DELETE","title":"DELETE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DELETE = STATE_REASON_DELETE\n</code></pre> <p>The order was deleted.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.FULL_EXECUTION","title":"FULL_EXECUTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FULL_EXECUTION = STATE_REASON_FULL_EXECUTION\n</code></pre> <p>The order was fully executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.ICEBERG_SLICE_ADD","title":"ICEBERG_SLICE_ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ICEBERG_SLICE_ADD = STATE_REASON_ICEBERG_SLICE_ADD\n</code></pre> <p>An iceberg slice was added.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.MODIFY","title":"MODIFY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MODIFY = STATE_REASON_MODIFY\n</code></pre> <p>The order was modified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.PARTIAL_EXECUTION","title":"PARTIAL_EXECUTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARTIAL_EXECUTION = STATE_REASON_PARTIAL_EXECUTION\n</code></pre> <p>The order was partially executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.QUOTE_ADD","title":"QUOTE_ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUOTE_ADD = STATE_REASON_QUOTE_ADD\n</code></pre> <p>A quote was added.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.QUOTE_FULL_EXECUTION","title":"QUOTE_FULL_EXECUTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUOTE_FULL_EXECUTION = STATE_REASON_QUOTE_FULL_EXECUTION\n</code></pre> <p>A quote was fully executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.QUOTE_PARTIAL_EXECUTION","title":"QUOTE_PARTIAL_EXECUTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUOTE_PARTIAL_EXECUTION = (\n    STATE_REASON_QUOTE_PARTIAL_EXECUTION\n)\n</code></pre> <p>A quote was partially executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.REJECT","title":"REJECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REJECT = STATE_REASON_REJECT\n</code></pre> <p>The order was rejected.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.UNKNOWN_STATE","title":"UNKNOWN_STATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN_STATE = STATE_REASON_UNKNOWN_STATE\n</code></pre> <p>The state of the order is unknown.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = STATE_REASON_UNSPECIFIED\n</code></pre> <p>The reason for the state change has not been specified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.VALIDATION_FAIL","title":"VALIDATION_FAIL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VALIDATION_FAIL = STATE_REASON_VALIDATION_FAIL\n</code></pre> <p>The order failed validation.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(state_reason: ValueType) -&gt; 'StateReason'\n</code></pre> <p>Convert a protobuf StateReason value to StateReason enum.</p> PARAMETER DESCRIPTION <code>state_reason</code> <p>State reason to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'StateReason'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls,\n    state_reason: electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType,\n) -&gt; \"StateReason\":\n    \"\"\"Convert a protobuf StateReason value to StateReason enum.\n\n    Args:\n        state_reason: State reason to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == state_reason for e in cls):\n        _logger.warning(\n            \"Unknown state reason %s. Returning UNSPECIFIED.\", state_reason\n        )\n        return cls.UNSPECIFIED\n\n    return cls(state_reason)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a StateReason enum to protobuf StateReason value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the StateReason enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(\n    self,\n) -&gt; electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType:\n    \"\"\"Convert a StateReason enum to protobuf StateReason value.\n\n    Returns:\n        Protobuf message corresponding to the StateReason enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade","title":"frequenz.client.electricity_trading.Trade  <code>dataclass</code>","text":"<p>Represents a private trade in the electricity market.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass Trade:  # pylint: disable=too-many-instance-attributes\n    \"\"\"Represents a private trade in the electricity market.\"\"\"\n\n    id: int\n    \"\"\"ID of the trade.\"\"\"\n\n    order_id: int\n    \"\"\"ID of the corresponding order.\"\"\"\n\n    side: MarketSide\n    \"\"\"Indicates if the trade's order was on the Buy or Sell side of the\n    market.\"\"\"\n\n    delivery_area: DeliveryArea\n    \"\"\"Delivery area of the trade.\"\"\"\n\n    delivery_period: DeliveryPeriod\n    \"\"\"The delivery period for the contract.\"\"\"\n\n    execution_time: datetime\n    \"\"\"UTC Timestamp of the trade's execution time.\"\"\"\n\n    price: Price\n    \"\"\"The price at which the trade was executed.\"\"\"\n\n    quantity: Energy\n    \"\"\"The executed quantity of the trade.\"\"\"\n\n    state: TradeState\n    \"\"\"Current state of the trade.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n        if self.execution_time.tzinfo is None:\n            raise ValueError(\"Execution time must have timezone information\")\n        if self.execution_time.tzinfo != timezone.utc:\n            _logger.warning(\"Execution timenis not in UTC timezone. Converting to UTC.\")\n            self.execution_time = self.execution_time.astimezone(timezone.utc)\n\n    @classmethod\n    def from_pb(cls, trade: electricity_trading_pb2.Trade) -&gt; Self:\n        \"\"\"Convert a protobuf Trade to Trade object.\n\n        Args:\n            trade: Trade to convert.\n\n        Returns:\n            Trade object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            id=trade.id,\n            order_id=trade.order_id,\n            side=MarketSide.from_pb(trade.side),\n            delivery_area=DeliveryArea.from_pb(trade.delivery_area),\n            delivery_period=DeliveryPeriod.from_pb(trade.delivery_period),\n            execution_time=trade.execution_time.ToDatetime(tzinfo=timezone.utc),\n            price=Price.from_pb(trade.price),\n            quantity=Energy.from_pb(trade.quantity),\n            state=TradeState.from_pb(trade.state),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.Trade:\n        \"\"\"Convert a Trade object to protobuf Trade.\n\n        Returns:\n            Protobuf message corresponding to the Trade object.\n        \"\"\"\n        execution_time = timestamp_pb2.Timestamp()\n        execution_time.FromDatetime(self.execution_time)\n\n        return electricity_trading_pb2.Trade(\n            id=self.id,\n            order_id=self.order_id,\n            side=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\n            delivery_area=self.delivery_area.to_pb(),\n            delivery_period=self.delivery_period.to_pb(),\n            execution_time=execution_time,\n            price=self.price.to_pb(),\n            quantity=self.quantity.to_pb(),\n            state=electricity_trading_pb2.TradeState.ValueType(self.state.value),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.delivery_area","title":"delivery_area  <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea\n</code></pre> <p>Delivery area of the trade.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.execution_time","title":"execution_time  <code>instance-attribute</code>","text":"<pre><code>execution_time: datetime\n</code></pre> <p>UTC Timestamp of the trade's execution time.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>ID of the trade.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.order_id","title":"order_id  <code>instance-attribute</code>","text":"<pre><code>order_id: int\n</code></pre> <p>ID of the corresponding order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: Price\n</code></pre> <p>The price at which the trade was executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: Energy\n</code></pre> <p>The executed quantity of the trade.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.side","title":"side  <code>instance-attribute</code>","text":"<pre><code>side: MarketSide\n</code></pre> <p>Indicates if the trade's order was on the Buy or Sell side of the market.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: TradeState\n</code></pre> <p>Current state of the trade.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n    if self.execution_time.tzinfo is None:\n        raise ValueError(\"Execution time must have timezone information\")\n    if self.execution_time.tzinfo != timezone.utc:\n        _logger.warning(\"Execution timenis not in UTC timezone. Converting to UTC.\")\n        self.execution_time = self.execution_time.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(trade: Trade) -&gt; Self\n</code></pre> <p>Convert a protobuf Trade to Trade object.</p> PARAMETER DESCRIPTION <code>trade</code> <p>Trade to convert.</p> <p> TYPE: <code>Trade</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Trade object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, trade: electricity_trading_pb2.Trade) -&gt; Self:\n    \"\"\"Convert a protobuf Trade to Trade object.\n\n    Args:\n        trade: Trade to convert.\n\n    Returns:\n        Trade object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        id=trade.id,\n        order_id=trade.order_id,\n        side=MarketSide.from_pb(trade.side),\n        delivery_area=DeliveryArea.from_pb(trade.delivery_area),\n        delivery_period=DeliveryPeriod.from_pb(trade.delivery_period),\n        execution_time=trade.execution_time.ToDatetime(tzinfo=timezone.utc),\n        price=Price.from_pb(trade.price),\n        quantity=Energy.from_pb(trade.quantity),\n        state=TradeState.from_pb(trade.state),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Trade\n</code></pre> <p>Convert a Trade object to protobuf Trade.</p> RETURNS DESCRIPTION <code>Trade</code> <p>Protobuf message corresponding to the Trade object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.Trade:\n    \"\"\"Convert a Trade object to protobuf Trade.\n\n    Returns:\n        Protobuf message corresponding to the Trade object.\n    \"\"\"\n    execution_time = timestamp_pb2.Timestamp()\n    execution_time.FromDatetime(self.execution_time)\n\n    return electricity_trading_pb2.Trade(\n        id=self.id,\n        order_id=self.order_id,\n        side=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\n        delivery_area=self.delivery_area.to_pb(),\n        delivery_period=self.delivery_period.to_pb(),\n        execution_time=execution_time,\n        price=self.price.to_pb(),\n        quantity=self.quantity.to_pb(),\n        state=electricity_trading_pb2.TradeState.ValueType(self.state.value),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState","title":"frequenz.client.electricity_trading.TradeState","text":"<p>               Bases: <code>Enum</code></p> <p>State of a trade.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class TradeState(enum.Enum):\n    \"\"\"State of a trade.\"\"\"\n\n    UNSPECIFIED = electricity_trading_pb2.TradeState.TRADE_STATE_UNSPECIFIED\n    \"\"\"The state is not known.\"\"\"\n\n    ACTIVE = electricity_trading_pb2.TradeState.TRADE_STATE_ACTIVE\n    \"\"\"The trade has been executed in the market.\"\"\"\n\n    CANCEL_REQUESTED = electricity_trading_pb2.TradeState.TRADE_STATE_CANCEL_REQUESTED\n    \"\"\"A cancellation request for the trade has been submitted.\"\"\"\n\n    CANCEL_REJECTED = electricity_trading_pb2.TradeState.TRADE_STATE_CANCEL_REJECTED\n    \"\"\"The trade cancellation request was rejected.\"\"\"\n\n    CANCELED = electricity_trading_pb2.TradeState.TRADE_STATE_CANCELED\n    \"\"\"The trade has been cancelled. This can occur due to a cancellation request by the market\n    participant, system, or market operator.\"\"\"\n\n    RECALL = electricity_trading_pb2.TradeState.TRADE_STATE_RECALLED\n    \"\"\"The trade has been recalled. This could be due to a system issue or a request from the market\n    participant or market operator.\"\"\"\n\n    RECALL_REQUESTED = electricity_trading_pb2.TradeState.TRADE_STATE_RECALL_REQUESTED\n    \"\"\"A recall request for the trade has been submitted.\"\"\"\n\n    RECALL_REJECTED = electricity_trading_pb2.TradeState.TRADE_STATE_RECALL_REJECTED\n    \"\"\"The trade recall request was rejected.\"\"\"\n\n    APPROVAL_REQUESTED = (\n        electricity_trading_pb2.TradeState.TRADE_STATE_APPROVAL_REQUESTED\n    )\n    \"\"\"An approval has been requested.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, trade_state: electricity_trading_pb2.TradeState.ValueType\n    ) -&gt; \"TradeState\":\n        \"\"\"Convert a protobuf TradeState value to TradeState enum.\n\n        Args:\n            trade_state: The trade state to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == trade_state for e in cls):\n            _logger.warning(\n                \"Unknown trade state %s. Returning UNSPECIFIED.\", trade_state\n            )\n            return cls.UNSPECIFIED\n\n        return cls(trade_state)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.TradeState.ValueType:\n        \"\"\"Convert a TradeState enum to protobuf TradeState value.\n\n        Returns:\n            Protobuf message corresponding to the TradeState enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.ACTIVE","title":"ACTIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE = TRADE_STATE_ACTIVE\n</code></pre> <p>The trade has been executed in the market.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.APPROVAL_REQUESTED","title":"APPROVAL_REQUESTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>APPROVAL_REQUESTED = TRADE_STATE_APPROVAL_REQUESTED\n</code></pre> <p>An approval has been requested.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.CANCELED","title":"CANCELED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCELED = TRADE_STATE_CANCELED\n</code></pre> <p>The trade has been cancelled. This can occur due to a cancellation request by the market participant, system, or market operator.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.CANCEL_REJECTED","title":"CANCEL_REJECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCEL_REJECTED = TRADE_STATE_CANCEL_REJECTED\n</code></pre> <p>The trade cancellation request was rejected.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.CANCEL_REQUESTED","title":"CANCEL_REQUESTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCEL_REQUESTED = TRADE_STATE_CANCEL_REQUESTED\n</code></pre> <p>A cancellation request for the trade has been submitted.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.RECALL","title":"RECALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RECALL = TRADE_STATE_RECALLED\n</code></pre> <p>The trade has been recalled. This could be due to a system issue or a request from the market participant or market operator.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.RECALL_REJECTED","title":"RECALL_REJECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RECALL_REJECTED = TRADE_STATE_RECALL_REJECTED\n</code></pre> <p>The trade recall request was rejected.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.RECALL_REQUESTED","title":"RECALL_REQUESTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RECALL_REQUESTED = TRADE_STATE_RECALL_REQUESTED\n</code></pre> <p>A recall request for the trade has been submitted.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = TRADE_STATE_UNSPECIFIED\n</code></pre> <p>The state is not known.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(trade_state: ValueType) -&gt; 'TradeState'\n</code></pre> <p>Convert a protobuf TradeState value to TradeState enum.</p> PARAMETER DESCRIPTION <code>trade_state</code> <p>The trade state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'TradeState'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, trade_state: electricity_trading_pb2.TradeState.ValueType\n) -&gt; \"TradeState\":\n    \"\"\"Convert a protobuf TradeState value to TradeState enum.\n\n    Args:\n        trade_state: The trade state to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == trade_state for e in cls):\n        _logger.warning(\n            \"Unknown trade state %s. Returning UNSPECIFIED.\", trade_state\n        )\n        return cls.UNSPECIFIED\n\n    return cls(trade_state)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a TradeState enum to protobuf TradeState value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the TradeState enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.TradeState.ValueType:\n    \"\"\"Convert a TradeState enum to protobuf TradeState value.\n\n    Returns:\n        Protobuf message corresponding to the TradeState enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder","title":"frequenz.client.electricity_trading.UpdateOrder  <code>dataclass</code>","text":"<p>Represents the order properties that can be updated after an order has been placed.</p> <p>At least one of the optional fields must be set for an update to take place.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass UpdateOrder:  # pylint: disable=too-many-instance-attributes\n    \"\"\"\n    Represents the order properties that can be updated after an order has been placed.\n\n    At least one of the optional fields must be set for an update to take place.\n    \"\"\"\n\n    price: Price | None = None\n    \"\"\"The updated limit price at which the contract is to be traded.\n    This is the maximum price for a BUY order or the minimum price for a SELL order.\"\"\"\n\n    quantity: Energy | None = None\n    \"\"\"The updated quantity of the contract being traded, specified in MWh.\"\"\"\n\n    stop_price: Price | None = None\n    \"\"\"Applicable for STOP_LIMIT orders. This is the updated stop price that triggers\n    the limit order.\"\"\"\n\n    peak_price_delta: Price | None = None\n    \"\"\"Applicable for ICEBERG orders. This is the updated price difference\n    between the peak price and the limit price.\"\"\"\n\n    display_quantity: Energy | None = None\n    \"\"\"Applicable for ICEBERG orders. This is the updated quantity of the order\n    to be displayed in the order book.\"\"\"\n\n    execution_option: OrderExecutionOption | None = None\n    \"\"\"Updated execution options such as All or None, Fill or Kill, etc.\"\"\"\n\n    valid_until: datetime | None = None\n    \"\"\"This is an updated timestamp defining the time after which the order should\n    be cancelled if not filled. The timestamp is in UTC.\"\"\"\n\n    payload: dict[str, struct_pb2.Value] | None = None\n    \"\"\"Updated user-defined payload individual to a specific order. This can be any data\n    that the user wants to associate with the order.\"\"\"\n\n    tag: str | None = None\n    \"\"\"Updated user-defined tag to group related orders.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n        if self.valid_until is not None:\n            if self.valid_until.tzinfo is None:\n                raise ValueError(\"Valid until must be a UTC datetime.\")\n            if self.valid_until.tzinfo != timezone.utc:\n                _logger.warning(\"Valid until is not a UTC datetime. Converting to UTC.\")\n                self.valid_until = self.valid_until.astimezone(timezone.utc)\n\n    @classmethod\n    def from_pb(\n        cls,\n        update_order: electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder,\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf UpdateOrder to UpdateOrder object.\n\n        Args:\n            update_order: UpdateOrder to convert.\n\n        Returns:\n            UpdateOrder object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            price=(\n                Price.from_pb(update_order.price)\n                if update_order.HasField(\"price\")\n                else None\n            ),\n            quantity=(\n                Energy.from_pb(update_order.quantity)\n                if update_order.HasField(\"quantity\")\n                else None\n            ),\n            stop_price=(\n                Price.from_pb(update_order.stop_price)\n                if update_order.HasField(\"stop_price\")\n                else None\n            ),\n            peak_price_delta=(\n                Price.from_pb(update_order.peak_price_delta)\n                if update_order.HasField(\"peak_price_delta\")\n                else None\n            ),\n            display_quantity=(\n                Energy.from_pb(update_order.display_quantity)\n                if update_order.HasField(\"display_quantity\")\n                else None\n            ),\n            execution_option=(\n                OrderExecutionOption.from_pb(update_order.execution_option)\n                if update_order.HasField(\"execution_option\")\n                else None\n            ),\n            valid_until=(\n                update_order.valid_until.ToDatetime(tzinfo=timezone.utc)\n                if update_order.HasField(\"valid_until\")\n                else None\n            ),\n            payload=(\n                json_format.MessageToDict(update_order.payload)\n                if update_order.payload\n                else None\n            ),\n            tag=update_order.tag if update_order.HasField(\"tag\") else None,\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder:\n        \"\"\"Convert a UpdateOrder object to protobuf UpdateOrder.\n\n        Returns:\n            Protobuf UpdateOrder corresponding to the object.\n        \"\"\"\n        if self.valid_until:\n            valid_until = timestamp_pb2.Timestamp()\n            valid_until.FromDatetime(self.valid_until)\n        else:\n            valid_until = None\n        return electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder(\n            price=self.price.to_pb() if self.price else None,\n            quantity=self.quantity.to_pb() if self.quantity else None,\n            stop_price=self.stop_price.to_pb() if self.stop_price else None,\n            peak_price_delta=(\n                self.peak_price_delta.to_pb() if self.peak_price_delta else None\n            ),\n            display_quantity=(\n                self.display_quantity.to_pb() if self.display_quantity else None\n            ),\n            execution_option=(\n                electricity_trading_pb2.OrderExecutionOption.ValueType(\n                    self.execution_option.value\n                )\n                if self.execution_option\n                else None\n            ),\n            valid_until=valid_until if self.valid_until else None,\n            payload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\n            tag=self.tag if self.tag else None,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.display_quantity","title":"display_quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>display_quantity: Energy | None = None\n</code></pre> <p>Applicable for ICEBERG orders. This is the updated quantity of the order to be displayed in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.execution_option","title":"execution_option  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execution_option: OrderExecutionOption | None = None\n</code></pre> <p>Updated execution options such as All or None, Fill or Kill, etc.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.payload","title":"payload  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Value] | None = None\n</code></pre> <p>Updated user-defined payload individual to a specific order. This can be any data that the user wants to associate with the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.peak_price_delta","title":"peak_price_delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>peak_price_delta: Price | None = None\n</code></pre> <p>Applicable for ICEBERG orders. This is the updated price difference between the peak price and the limit price.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.price","title":"price  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>price: Price | None = None\n</code></pre> <p>The updated limit price at which the contract is to be traded. This is the maximum price for a BUY order or the minimum price for a SELL order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: Energy | None = None\n</code></pre> <p>The updated quantity of the contract being traded, specified in MWh.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.stop_price","title":"stop_price  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_price: Price | None = None\n</code></pre> <p>Applicable for STOP_LIMIT orders. This is the updated stop price that triggers the limit order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str | None = None\n</code></pre> <p>Updated user-defined tag to group related orders.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.valid_until","title":"valid_until  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>valid_until: datetime | None = None\n</code></pre> <p>This is an updated timestamp defining the time after which the order should be cancelled if not filled. The timestamp is in UTC.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n    if self.valid_until is not None:\n        if self.valid_until.tzinfo is None:\n            raise ValueError(\"Valid until must be a UTC datetime.\")\n        if self.valid_until.tzinfo != timezone.utc:\n            _logger.warning(\"Valid until is not a UTC datetime. Converting to UTC.\")\n            self.valid_until = self.valid_until.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(update_order: UpdateOrder) -&gt; Self\n</code></pre> <p>Convert a protobuf UpdateOrder to UpdateOrder object.</p> PARAMETER DESCRIPTION <code>update_order</code> <p>UpdateOrder to convert.</p> <p> TYPE: <code>UpdateOrder</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>UpdateOrder object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls,\n    update_order: electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder,\n) -&gt; Self:\n    \"\"\"Convert a protobuf UpdateOrder to UpdateOrder object.\n\n    Args:\n        update_order: UpdateOrder to convert.\n\n    Returns:\n        UpdateOrder object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        price=(\n            Price.from_pb(update_order.price)\n            if update_order.HasField(\"price\")\n            else None\n        ),\n        quantity=(\n            Energy.from_pb(update_order.quantity)\n            if update_order.HasField(\"quantity\")\n            else None\n        ),\n        stop_price=(\n            Price.from_pb(update_order.stop_price)\n            if update_order.HasField(\"stop_price\")\n            else None\n        ),\n        peak_price_delta=(\n            Price.from_pb(update_order.peak_price_delta)\n            if update_order.HasField(\"peak_price_delta\")\n            else None\n        ),\n        display_quantity=(\n            Energy.from_pb(update_order.display_quantity)\n            if update_order.HasField(\"display_quantity\")\n            else None\n        ),\n        execution_option=(\n            OrderExecutionOption.from_pb(update_order.execution_option)\n            if update_order.HasField(\"execution_option\")\n            else None\n        ),\n        valid_until=(\n            update_order.valid_until.ToDatetime(tzinfo=timezone.utc)\n            if update_order.HasField(\"valid_until\")\n            else None\n        ),\n        payload=(\n            json_format.MessageToDict(update_order.payload)\n            if update_order.payload\n            else None\n        ),\n        tag=update_order.tag if update_order.HasField(\"tag\") else None,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; UpdateOrder\n</code></pre> <p>Convert a UpdateOrder object to protobuf UpdateOrder.</p> RETURNS DESCRIPTION <code>UpdateOrder</code> <p>Protobuf UpdateOrder corresponding to the object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder:\n    \"\"\"Convert a UpdateOrder object to protobuf UpdateOrder.\n\n    Returns:\n        Protobuf UpdateOrder corresponding to the object.\n    \"\"\"\n    if self.valid_until:\n        valid_until = timestamp_pb2.Timestamp()\n        valid_until.FromDatetime(self.valid_until)\n    else:\n        valid_until = None\n    return electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder(\n        price=self.price.to_pb() if self.price else None,\n        quantity=self.quantity.to_pb() if self.quantity else None,\n        stop_price=self.stop_price.to_pb() if self.stop_price else None,\n        peak_price_delta=(\n            self.peak_price_delta.to_pb() if self.peak_price_delta else None\n        ),\n        display_quantity=(\n            self.display_quantity.to_pb() if self.display_quantity else None\n        ),\n        execution_option=(\n            electricity_trading_pb2.OrderExecutionOption.ValueType(\n                self.execution_option.value\n            )\n            if self.execution_option\n            else None\n        ),\n        valid_until=valid_until if self.valid_until else None,\n        payload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\n        tag=self.tag if self.tag else None,\n    )\n</code></pre>"}]}